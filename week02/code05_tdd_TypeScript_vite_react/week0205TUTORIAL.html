<!DOCTYPE html>
<html>
<head>
<title>week0205TUTORIAL.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="week-02---code-05-test-driven-development-with-typescript-vite--react">Week 02 - Code 05: Test-Driven Development with TypeScript, Vite &amp; React</h1>
<h2 id="the-tdd-journey-building-quality-software-from-the-inside-out">The TDD Journey: Building Quality Software from the Inside Out</h2>
<pre class="hljs"><code><div>Traditional Development:
Write Code → Test Later → Debug Forever → Fear Changes
     ↓           ↓            ↓              ↓
   Fast       Stressful    Time Sink     Brittle Code

TDD Approach:
Write Test → Write Code → Refactor → Repeat
     ↓           ↓           ↓          ↓
   Think      Minimal    Improve    Confidence
</div></code></pre>
<h2 id="learning-objectives">Learning Objectives</h2>
<p>By the end of this tutorial, you will:</p>
<ol>
<li>Understand Test-Driven Development (TDD) principles and methodology</li>
<li>Experience the Red-Green-Refactor cycle firsthand</li>
<li>Build the same chatbot from Week 02-04 using TDD approach</li>
<li>Write unit tests, integration tests, and end-to-end tests</li>
<li>Use Jest, React Testing Library, and Cypress for comprehensive testing</li>
<li>Understand how TDD improves code quality and developer confidence</li>
<li>Learn testing best practices for React TypeScript applications</li>
</ol>
<h2 id="%F0%9F%93%8D-how-to-track-your-progress">📍 How to Track Your Progress</h2>
<p><strong>Important for Students:</strong> Each test file in this tutorial includes a step number comment at the top:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🧪 Step 5: TDD Red Phase - Message Utils Test</span>
<span class="hljs-comment">// � Step 6: TDD Strategies - Triangulation  </span>
<span class="hljs-comment">// �📝 Step 7: Message Types Test (Inside-Out Approach)</span>
<span class="hljs-comment">// 🤖 Step 8: Bot Response Logic</span>
<span class="hljs-comment">// 🪝 Step 9: Message Creation Hook</span>
<span class="hljs-comment">// 📄 Step 10: Message Component Tests</span>
<span class="hljs-comment">// ⌨️ Step 11: Chat Input Component Tests</span>
<span class="hljs-comment">// 💬 Step 12: Main Chat Component Tests</span>
</div></code></pre>
<p><strong>Why This Helps:</strong></p>
<ul>
<li><strong>Copy &amp; Paste Safely:</strong> When you copy code from the tutorial, the step number tells you exactly where you are</li>
<li><strong>Progress Tracking:</strong> Easily see which step you're working on without scrolling through the tutorial</li>
<li><strong>Debugging:</strong> If tests fail, you know exactly which tutorial step to reference</li>
<li><strong>Team Collaboration:</strong> Share your progress with others by mentioning the step number</li>
</ul>
<p><strong>Step Number Legend:</strong></p>
<ul>
<li>🧪 = Utility/Helper Functions (Steps 5-6)</li>
<li>📝 = Core Types &amp; Logic (Steps 7-8)</li>
<li>🪝 = React Hooks (Step 9)</li>
<li>📄 = React Components (Steps 10-13)</li>
<li>🎯 = Integration &amp; Advanced Testing (Steps 14-16)</li>
</ul>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#understanding-test-driven-development">Understanding Test-Driven Development</a></li>
<li><a href="#setting-up-the-tdd-environment">Setting Up the TDD Environment</a></li>
<li><a href="#tdd-fundamentals-red-green-refactor">TDD Fundamentals: Red-Green-Refactor</a></li>
<li><a href="#building-our-chatbot-with-tdd">Building Our Chatbot with TDD</a></li>
<li><a href="#unit-testing-with-jest">Unit Testing with Jest</a></li>
<li><a href="#component-testing-with-react-testing-library">Component Testing with React Testing Library</a></li>
<li><a href="#integration-testing">Integration Testing</a></li>
<li><a href="#end-to-end-testing-with-cypress">End-to-End Testing with Cypress</a></li>
<li><a href="#advanced-tdd-techniques">Advanced TDD Techniques</a></li>
<li><a href="#tdd-best-practices-and-common-pitfalls">TDD Best Practices and Common Pitfalls</a></li>
</ol>
<h2 id="understanding-test-driven-development">Understanding Test-Driven Development</h2>
<h3 id="what-is-tdd">What is TDD?</h3>
<p><strong>Test-Driven Development (TDD)</strong> is a software development process where you write tests before writing the actual code. It's not just about testing—it's a design methodology that helps you build better, more maintainable software.</p>
<h3 id="the-problem-with-code-first-development">The Problem with Code-First Development</h3>
<p><strong>Traditional Approach Problems:</strong></p>
<ul>
<li>❌ High level of defects discovered late</li>
<li>❌ Lengthy testing phases after development</li>
<li>❌ Poor code maintainability</li>
<li>❌ Fear of making changes (brittle code)</li>
<li>❌ Running out of time for proper testing</li>
<li>❌ Expensive bug fixes in production</li>
</ul>
<h3 id="the-tdd-solution">The TDD Solution</h3>
<p><strong>TDD Benefits:</strong></p>
<ul>
<li>✅ Reduces bugs through early detection</li>
<li>✅ Improves code quality and design</li>
<li>✅ Makes refactoring safer</li>
<li>✅ Ensures code meets requirements</li>
<li>✅ Builds developer confidence</li>
<li>✅ Creates comprehensive test library</li>
<li>✅ Acts as living documentation</li>
<li>✅ Achieves excellent code coverage</li>
</ul>
<h3 id="the-red-green-refactor-cycle">The Red-Green-Refactor Cycle</h3>
<p><strong>🔴 RED: Write a Failing Test</strong></p>
<ul>
<li>Write the smallest possible test that fails</li>
<li>Think about the desired behavior first</li>
<li>Focus on the interface, not implementation</li>
</ul>
<p><strong>🟢 GREEN: Make It Pass</strong></p>
<ul>
<li>Write the minimal code to make the test pass</li>
<li>Don't worry about perfection</li>
<li>Just make it work</li>
</ul>
<p><strong>🔵 REFACTOR: Improve the Code</strong></p>
<ul>
<li>Clean up both test and production code</li>
<li>Remove duplication</li>
<li>Improve readability</li>
<li>Tests ensure nothing breaks</li>
</ul>
<h2 id="%F0%9F%93%8B-tdd-tutorial-progress-tracker">📋 TDD Tutorial Progress Tracker</h2>
<p><strong>Use this checklist to track your progress:</strong></p>
<ul>
<li>
<p><input type="checkbox" id="checkbox0"><label for="checkbox0"></label><strong>Phase 1: Setup</strong> (Steps 1-4)</p>
<ul>
<li><input type="checkbox" id="checkbox1"><label for="checkbox1"></label><a href="#%F0%9F%9A%80-step-1-create-tdd-project">🚀 Step 1: Create TDD Project</a></li>
<li><input type="checkbox" id="checkbox2"><label for="checkbox2"></label><a href="#%F0%9F%93%A6-step-2-install-testing-dependencies">📦 Step 2: Install Testing Dependencies</a></li>
<li><input type="checkbox" id="checkbox3"><label for="checkbox3"></label><a href="#%E2%9A%99%EF%B8%8F-step-3-configure-testing-environment">⚙️ Step 3: Configure Testing Environment</a></li>
<li><input type="checkbox" id="checkbox4"><label for="checkbox4"></label><a href="#%E2%9C%85-step-4-verify-setup">✅ Step 4: Verify Setup</a></li>
</ul>
</li>
<li>
<p><input type="checkbox" id="checkbox5"><label for="checkbox5"></label><strong>Phase 2: TDD Fundamentals</strong> (Steps 5-6)</p>
<ul>
<li><input type="checkbox" id="checkbox6"><label for="checkbox6"></label><a href="#%F0%9F%A7%AA-step-5-testing-a-simple-utility-function">🧪 Step 5: Testing a Simple Utility Function</a></li>
<li><input type="checkbox" id="checkbox7"><label for="checkbox7"></label><a href="#%F0%9F%94%84-step-6-tdd-strategies---triangulation">🔄 Step 6: TDD Strategies - Triangulation</a></li>
</ul>
</li>
<li>
<p><input type="checkbox" id="checkbox8"><label for="checkbox8"></label><strong>Phase 3: Core Logic</strong> (Steps 7-9)</p>
<ul>
<li><input type="checkbox" id="checkbox9"><label for="checkbox9"></label><a href="#%F0%9F%93%9D-step-7-message-types-inside-out-approach">📝 Step 7: Message Types (Inside-Out Approach)</a></li>
<li><input type="checkbox" id="checkbox10"><label for="checkbox10"></label><a href="#%F0%9F%A4%96-step-8-bot-response-logic">🤖 Step 8: Bot Response Logic</a></li>
<li><input type="checkbox" id="checkbox11"><label for="checkbox11"></label><a href="#%F0%9F%AA%9D-step-9-message-creation-hook">🪝 Step 9: Message Creation Hook</a></li>
</ul>
</li>
<li>
<p><input type="checkbox" id="checkbox12"><label for="checkbox12"></label><strong>Phase 4: React Components</strong> (Steps 10-13)</p>
<ul>
<li><input type="checkbox" id="checkbox13"><label for="checkbox13"></label><a href="#%F0%9F%93%84-step-10-message-component">📄 Step 10: Message Component</a></li>
<li><input type="checkbox" id="checkbox14"><label for="checkbox14"></label><a href="#%E2%8C%A8%EF%B8%8F-step-11-chat-input-component">⌨️ Step 11: Chat Input Component</a></li>
<li><input type="checkbox" id="checkbox15"><label for="checkbox15"></label><a href="#%F0%9F%92%AC-step-12-main-chat-component">💬 Step 12: Main Chat Component</a></li>
<li><input type="checkbox" id="checkbox16"><label for="checkbox16"></label><a href="#%F0%9F%8E%AF-step-13-app-component-integration">🎯 Step 13: App Component Integration</a></li>
</ul>
</li>
<li>
<p><input type="checkbox" id="checkbox17"><label for="checkbox17"></label><strong>Phase 5: Advanced Testing</strong> (Steps 14-16)</p>
<ul>
<li><input type="checkbox" id="checkbox18"><label for="checkbox18"></label><a href="#%F0%9F%A7%AA-step-14-integration-testing">🧪 Step 14: Integration Testing</a></li>
<li><input type="checkbox" id="checkbox19"><label for="checkbox19"></label><a href="#%F0%9F%8C%90-step-15-end-to-end-testing-with-cypress">� Step 15: End-to-End Testing with Cypress</a></li>
<li><input type="checkbox" id="checkbox20"><label for="checkbox20"></label><a href="#%F0%9F%9A%80-step-16-advanced-tdd-techniques">🚀 Step 16: Advanced TDD Techniques</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="setting-up-the-tdd-environment">Setting Up the TDD Environment</h2>
<h3 id="prerequisites">Prerequisites</h3>
<p>Before starting, ensure you have completed Week 02-04 or have Node.js installed.</p>
<h3 id="%F0%9F%9A%80-step-1-create-tdd-project">🚀 Step 1: Create TDD Project</h3>
<p><strong>Code 1.1: Project Setup Commands</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Navigate to the TDD directory</span>
<span class="hljs-built_in">cd</span> <span class="hljs-string">"week02\code05_tdd_TypeScript_vite_react"</span>

<span class="hljs-comment"># Create a new Vite React TypeScript project</span>
<span class="hljs-comment"># Select React + TypeScript</span>
npm create vite@latest chatbot-tdd-app --template react-ts

<span class="hljs-comment"># Navigate into the project</span>
<span class="hljs-built_in">cd</span> chatbot-tdd-app

<span class="hljs-comment"># Install dependencies</span>
npm install
</div></code></pre>
<h3 id="%F0%9F%93%A6-step-2-install-testing-dependencies">📦 Step 2: Install Testing Dependencies</h3>
<p><strong>Code 2.1: Testing Dependencies Installation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Install Jest and React Testing Library (Vite doesn't include Jest by default)</span>
npm install --save-dev @testing-library/react @testing-library/jest-dom @testing-library/user-event

<span class="hljs-comment"># Install Jest and TypeScript support</span>
npm install --save-dev jest ts-jest @types/jest

<span class="hljs-comment"># Install Cypress for E2E testing</span>
npm install --save-dev cypress

<span class="hljs-comment"># Install additional testing utilities</span>
npm install --save-dev jest-environment-jsdom identity-obj-proxy
</div></code></pre>
<h3 id="%E2%9A%99%EF%B8%8F-step-3-configure-testing-environment">⚙️ Step 3: Configure Testing Environment</h3>
<p><strong>Code 3.1: Update package.json Scripts</strong></p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"dev"</span>: <span class="hljs-string">"vite"</span>,
    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"tsc &amp;&amp; vite build"</span>,
    <span class="hljs-attr">"preview"</span>: <span class="hljs-string">"vite preview"</span>,
    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"jest"</span>,
    <span class="hljs-attr">"test:watch"</span>: <span class="hljs-string">"jest --watch"</span>,
    <span class="hljs-attr">"test:coverage"</span>: <span class="hljs-string">"jest --coverage"</span>,
    <span class="hljs-attr">"test:e2e"</span>: <span class="hljs-string">"cypress open"</span>,
    <span class="hljs-attr">"test:e2e:headless"</span>: <span class="hljs-string">"cypress run"</span>
  }
}
</div></code></pre>
<p><strong>Code 3.2: Create jest.config.js</strong></p>
<p>See &quot;extra readings&quot;</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Jest configuration for React TypeScript project</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// Use ts-jest preset for TypeScript support</span>
  <span class="hljs-attr">preset</span>: <span class="hljs-string">'ts-jest'</span>,
  <span class="hljs-comment">// Use jsdom to simulate browser environment for React components</span>
  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">'jsdom'</span>,
  <span class="hljs-comment">// Run setup file after Jest environment is set up</span>
  <span class="hljs-attr">setupFilesAfterEnv</span>: [<span class="hljs-string">'&lt;rootDir&gt;/src/setupTests.ts'</span>],
  <span class="hljs-comment">// Mock CSS imports so tests don't break on style imports</span>
  <span class="hljs-attr">moduleNameMapper</span>: {
    <span class="hljs-string">'\\.(css|less|scss|sass)$'</span>: <span class="hljs-string">'identity-obj-proxy'</span>,
  },
  <span class="hljs-comment">// Transform TypeScript and TSX files using ts-jest</span>
  <span class="hljs-attr">transform</span>: {
    <span class="hljs-string">'^.+\\.tsx?$'</span>: <span class="hljs-string">'ts-jest'</span>,
  },
  <span class="hljs-comment">// Define where Jest should look for test files</span>
  <span class="hljs-attr">testMatch</span>: [
    <span class="hljs-string">'&lt;rootDir&gt;/src/**/__tests__/**/*.{ts,tsx}'</span>, <span class="hljs-comment">// Tests in __tests__ folders</span>
    <span class="hljs-string">'&lt;rootDir&gt;/src/**/*.{test,spec}.{ts,tsx}'</span>,  <span class="hljs-comment">// Files ending with .test or .spec</span>
  ],
  <span class="hljs-comment">// Collect coverage from these files</span>
  <span class="hljs-attr">collectCoverageFrom</span>: [
    <span class="hljs-string">'src/**/*.{ts,tsx}'</span>,     <span class="hljs-comment">// Include all TypeScript files</span>
    <span class="hljs-string">'!src/**/*.d.ts'</span>,        <span class="hljs-comment">// Exclude type definition files</span>
    <span class="hljs-string">'!src/main.tsx'</span>,         <span class="hljs-comment">// Exclude entry point</span>
    <span class="hljs-string">'!src/vite-env.d.ts'</span>,    <span class="hljs-comment">// Exclude Vite environment types</span>
  ],
};
</div></code></pre>
<p><strong>🤔 Why Do We Need jest.config.js? - Essential Understanding</strong></p>
<p>You might wonder: &quot;Why can't we just run <code>npm test</code> and have everything work automatically?&quot; Great question! Here's why we need this configuration file:</p>
<p><strong>🎯 The Problem:</strong></p>
<p>Vite projects are optimized for modern web development, but Jest (our testing framework) was designed before some of these modern tools existed. They speak different &quot;languages&quot;:</p>
<pre class="hljs"><code><div>🏗️ Vite Project Speaks:
├── TypeScript (.ts/.tsx files)
├── Modern ES Modules (import/export)
├── CSS/SCSS imports
├── JSX syntax
└── Browser environment

🧪 Jest Speaks:
├── JavaScript by default
├── CommonJS modules (require/module.exports)
├── Node.js environment
└── No built-in JSX understanding
</div></code></pre>
<p><strong>🔧 What jest.config.js Does - Breaking It Down:</strong></p>
<p>Think of <code>jest.config.js</code> as a &quot;translator&quot; that helps Jest understand your modern Vite project:</p>
<p><strong>1. TypeScript Support (<code>preset: 'ts-jest'</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Without this: Jest sees .ts files and says "I don't understand this!"</span>
<span class="hljs-comment">// With this: Jest uses ts-jest to convert TypeScript → JavaScript before testing</span>

<span class="hljs-attr">preset</span>: <span class="hljs-string">'ts-jest'</span>  <span class="hljs-comment">// Tells Jest: "Use the ts-jest translator for TypeScript files"</span>
</div></code></pre>
<p><strong>2. Browser Environment Simulation (<code>testEnvironment: 'jsdom'</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Problem: React components expect a browser (DOM, window, document)</span>
<span class="hljs-comment">// Reality: Jest runs in Node.js (no DOM, no window)</span>

<span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">'jsdom'</span>  <span class="hljs-comment">// Creates a fake browser environment for testing</span>
</div></code></pre>
<p><strong>3. CSS Import Handling (<code>moduleNameMapper</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Your components do this:</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./Button.css'</span>;  <span class="hljs-comment">// Jest says: "What's a .css file?!"</span>

<span class="hljs-comment">// This fixes it:</span>
moduleNameMapper: {
  <span class="hljs-string">'\\.(css|less|scss|sass)$'</span>: <span class="hljs-string">'identity-obj-proxy'</span>  <span class="hljs-comment">// "Fake" CSS imports for testing</span>
}
</div></code></pre>
<p><strong>4. File Transformation (<code>transform</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Jest needs to know: "How do I process .tsx files?"</span>
<span class="hljs-attr">transform</span>: {
  <span class="hljs-string">'^.+\\.tsx?$'</span>: <span class="hljs-string">'ts-jest'</span>  <span class="hljs-comment">// "Use ts-jest to handle any .ts or .tsx file"</span>
}
</div></code></pre>
<p><strong>5. Test Discovery (<code>testMatch</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Jest asks: "Where are the test files?"</span>
<span class="hljs-attr">testMatch</span>: [
  <span class="hljs-string">'&lt;rootDir&gt;/src/**/__tests__/**/*.{ts,tsx}'</span>,  <span class="hljs-comment">// Look in __tests__ folders</span>
  <span class="hljs-string">'&lt;rootDir&gt;/src/**/*.{test,spec}.{ts,tsx}'</span>    <span class="hljs-comment">// Look for .test.ts files</span>
]
</div></code></pre>
<p><strong>🔍 Real-World Analogy:</strong></p>
<p>Imagine you're a Spanish speaker visiting Japan:</p>
<pre class="hljs"><code><div>🇪🇸 You (Vite Project):
- Speak Spanish (TypeScript)
- Use Spanish customs (ES Modules)
- Expect Spanish environment (Browser)

🇯🇵 Local System (Jest):
- Understands Japanese (JavaScript)
- Uses Japanese customs (CommonJS)
- Operates in Japanese context (Node.js)

📖 jest.config.js = Your Translator:
- Converts your Spanish → Japanese
- Explains your customs to locals
- Helps you navigate the environment
</div></code></pre>
<p><strong>🚨 What Happens Without jest.config.js:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># You run: npm test</span>
<span class="hljs-comment"># Jest tries to run your tests but...</span>

❌ <span class="hljs-string">"Cannot understand TypeScript files"</span>
❌ <span class="hljs-string">"Don't know what import/export means"</span>
❌ <span class="hljs-string">"CSS files crash the tests"</span>
❌ <span class="hljs-string">"JSX syntax is foreign to me"</span>
❌ <span class="hljs-string">"No browser environment available"</span>

Result: Tests fail before they even start! 😱
</div></code></pre>
<p><strong>✅ With jest.config.js:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># You run: npm test</span>
<span class="hljs-comment"># Jest reads the config file and...</span>

✅ <span class="hljs-string">"I'll use ts-jest to handle TypeScript"</span>
✅ <span class="hljs-string">"I'll convert ES modules to CommonJS"</span>
✅ <span class="hljs-string">"I'll mock CSS imports so they don't break"</span>
✅ <span class="hljs-string">"I'll process JSX through the TypeScript compiler"</span>
✅ <span class="hljs-string">"I'll create a fake browser environment"</span>

Result: Tests run smoothly! 🎉
</div></code></pre>
<p><strong>💡 Key Insight:</strong></p>
<p><code>jest.config.js</code> bridges the gap between modern development tools and testing frameworks. It's like having a universal adapter that makes incompatible systems work together perfectly.</p>
<p><strong>🎯 The Bottom Line:</strong></p>
<p>Without this file, you'd spend hours troubleshooting why your tests won't even start. With it, Jest becomes a powerful ally that understands your modern React TypeScript project and helps you build confidence through testing.</p>
<p><strong>Code 3.2.1: Create tsconfig.jest.json</strong></p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"extends"</span>: <span class="hljs-string">"./tsconfig.app.json"</span>,
  <span class="hljs-attr">"compilerOptions"</span>: {
    <span class="hljs-attr">"jsx"</span>: <span class="hljs-string">"react-jsx"</span>,
    <span class="hljs-attr">"esModuleInterop"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"allowSyntheticDefaultImports"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"module"</span>: <span class="hljs-string">"commonjs"</span>,
    <span class="hljs-attr">"verbatimModuleSyntax"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"noEmit"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"isolatedModules"</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">"include"</span>: [
    <span class="hljs-string">"src/**/*"</span>,
    <span class="hljs-string">"src/**/*.test.ts"</span>,
    <span class="hljs-string">"src/**/*.test.tsx"</span>,
    <span class="hljs-string">"src/**/*.spec.ts"</span>, 
    <span class="hljs-string">"src/**/*.spec.tsx"</span>
  ]
}
</div></code></pre>
<p><strong>🤔 Why Do We Need tsconfig.jest.json? - Advanced Configuration Understanding</strong></p>
<p>You might notice that we have both <code>jest.config.js</code> AND <code>tsconfig.jest.json</code>. Why two configuration files? Here's the deeper technical reasoning:</p>
<p><strong>🎯 The Core Problem:</strong></p>
<p>Your main TypeScript configuration (<code>tsconfig.app.json</code>) is optimized for <strong>modern web bundling</strong> with Vite, but Jest needs <strong>different TypeScript settings</strong> to run tests properly in a Node.js environment.</p>
<pre class="hljs"><code><div>🏗️ Production Build (tsconfig.app.json):
├── Target: Modern browsers
├── Module system: ESNext (import/export)
├── JSX: react-jsx (optimized)
├── Strict syntax: verbatimModuleSyntax: true
├── No emit: true (bundler handles output)
└── Environment: Browser

🧪 Testing Environment (tsconfig.jest.json):
├── Target: Node.js test runner
├── Module system: CommonJS (require/exports)
├── JSX: react-jsx (for test components)
├── Flexible syntax: verbatimModuleSyntax: false
├── Allow emit: false (ts-jest handles compilation)
└── Environment: Node.js with jsdom simulation
</div></code></pre>
<p><strong>🔧 Breaking Down Each Configuration Setting:</strong></p>
<p><strong>1. Configuration Inheritance (<code>extends</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-string">"extends"</span>: <span class="hljs-string">"./tsconfig.app.json"</span>  <span class="hljs-comment">// Start with your app config as base</span>
</div></code></pre>
<p>This means: &quot;Take all the settings from my main app config, then override specific ones for testing.&quot;</p>
<p><strong>2. Module System Compatibility (<code>module: &quot;commonjs&quot;</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Your app uses:</span>
import { useState } from 'react';     <span class="hljs-comment">// ESNext modules (modern)</span>

<span class="hljs-comment">// Jest needs:</span>
const { useState } = require('react'); <span class="hljs-comment">// CommonJS modules (Node.js)</span>

<span class="hljs-string">"module"</span>: <span class="hljs-string">"commonjs"</span>  <span class="hljs-comment">// Tells TypeScript: "Convert imports to require() for Jest"</span>
</div></code></pre>
<p><strong>3. Import/Export Flexibility (<code>verbatimModuleSyntax: false</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Your main app has strict module syntax:</span>
<span class="hljs-string">"verbatimModuleSyntax"</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">// Every import must be exactly what you mean</span>

<span class="hljs-comment">// Tests need flexibility:</span>
<span class="hljs-string">"verbatimModuleSyntax"</span>: <span class="hljs-literal">false</span>  <span class="hljs-comment">// Allow mixed import styles for testing utilities</span>
</div></code></pre>
<p><strong>4. Isolated Module Processing (<code>isolatedModules: false</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Production build:</span>
<span class="hljs-string">"isolatedModules"</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">// Each file must be compilable independently</span>

<span class="hljs-comment">// Testing environment:</span>
<span class="hljs-string">"isolatedModules"</span>: <span class="hljs-literal">false</span>  <span class="hljs-comment">// Allow more flexible cross-file dependencies for test utilities</span>
</div></code></pre>
<p><strong>5. TypeScript Compilation Control (<code>noEmit: false</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Production (Vite handles compilation):</span>
<span class="hljs-string">"noEmit"</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">// Don't output compiled JavaScript</span>

<span class="hljs-comment">// Testing (ts-jest needs compilation):</span>
<span class="hljs-string">"noEmit"</span>: <span class="hljs-literal">false</span>  <span class="hljs-comment">// Allow TypeScript compilation for test processing</span>
</div></code></pre>
<p><strong>🔍 Real-World Problem This Solves:</strong></p>
<p>Without <code>tsconfig.jest.json</code>, you'd encounter these specific errors:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Error 1: JSX Processing</span>
❌ error TS6142: Module <span class="hljs-string">'./Component'</span> was resolved to <span class="hljs-string">'Component.tsx'</span>, but <span class="hljs-string">'--jsx'</span> is not <span class="hljs-built_in">set</span>.

<span class="hljs-comment"># Error 2: Module System Mismatch  </span>
❌ error TS1371: This import is never used as a value and must use <span class="hljs-string">'import type'</span>.

<span class="hljs-comment"># Error 3: Strict Module Syntax</span>
❌ error TS1484: <span class="hljs-string">'SomeType'</span> is a <span class="hljs-built_in">type</span> and must be imported using a <span class="hljs-built_in">type</span>-only import when <span class="hljs-string">'verbatimModuleSyntax'</span> is enabled.

<span class="hljs-comment"># Error 4: Compilation Issues</span>
❌ Cannot use JSX unless the <span class="hljs-string">'--jsx'</span> flag is provided.
</div></code></pre>
<p><strong>✅ With tsconfig.jest.json:</strong></p>
<pre class="hljs"><code><div>✅ Jest can process .tsx files correctly
✅ TypeScript understands both import styles
✅ Module system matches Node.js expectations  
✅ Test utilities work seamlessly
✅ All tests run without TypeScript conflicts
</div></code></pre>
<p><strong>🎯 How Jest Uses This File:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// In jest.config.js:</span>
<span class="hljs-attr">transform</span>: {
  <span class="hljs-string">'^.+\\.tsx?$'</span>: [<span class="hljs-string">'ts-jest'</span>, {
    <span class="hljs-attr">tsconfig</span>: <span class="hljs-string">'tsconfig.jest.json'</span>  <span class="hljs-comment">// "Use THIS config for tests"</span>
  }]
}
</div></code></pre>
<p>This tells Jest: &quot;When you encounter TypeScript files during testing, use the <code>tsconfig.jest.json</code> configuration to compile them.&quot;</p>
<p><strong>💡 Key Architecture Insight:</strong></p>
<p>This is a common pattern in modern development:</p>
<pre class="hljs"><code><div>📁 Project Structure:
├── tsconfig.json          → Base configuration
├── tsconfig.app.json      → Production build settings  
├── tsconfig.jest.json     → Testing environment settings
├── tsconfig.node.json     → Build tools settings
└── jest.config.js         → Points to tsconfig.jest.json
</div></code></pre>
<p>Each tool gets <strong>exactly the TypeScript configuration it needs</strong> without compromising the others.</p>
<p><strong>🚨 What Happens Without This File:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Jest tries to use your main TypeScript config...</span>
<span class="hljs-comment"># But it's optimized for browsers, not Node.js testing!</span>

❌ Module import/<span class="hljs-built_in">export</span> conflicts
❌ JSX processing failures  
❌ Strict syntax checking breaks <span class="hljs-built_in">test</span> utilities
❌ TypeScript compilation errors <span class="hljs-keyword">in</span> <span class="hljs-built_in">test</span> files
❌ Hours of debugging configuration mismatches

Result: Tests fail due to configuration, not code issues! 😱
</div></code></pre>
<p><strong>✅ With tsconfig.jest.json:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Jest gets its own perfectly-tuned TypeScript config</span>

✅ Clean module resolution
✅ Proper JSX handling <span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> components
✅ Flexible import syntax <span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> utilities  
✅ Seamless TypeScript compilation
✅ Focus on writing tests, not fighting config

Result: Tests run smoothly, developers stay productive! 🎉
</div></code></pre>
<p><strong>🎯 The Professional Takeaway:</strong></p>
<p>Separating TypeScript configurations by environment is a <strong>professional development practice</strong>. It ensures that each tool (bundler, testing framework, build scripts) gets the exact configuration it needs without interference from other tools.</p>
<p><strong>Code 3.3: Create setupTests.ts</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Import Jest DOM matchers for enhanced testing assertions</span>
<span class="hljs-comment">// This adds custom matchers like toBeInTheDocument(), toHaveClass(), etc.</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'@testing-library/jest-dom'</span>;

<span class="hljs-comment">// Global mock for scrollIntoView - jsdom doesn't implement this browser API</span>
<span class="hljs-comment">// This prevents errors when components use scrollIntoView (like our Chat component will)</span>
<span class="hljs-built_in">Object</span>.defineProperty(Element.prototype, <span class="hljs-string">'scrollIntoView'</span>, {
  value: jest.fn(),
  writable: <span class="hljs-literal">true</span>,
});
</div></code></pre>
<p><strong>Why do we need <code>setupTests.ts</code>? - Detailed Explanation</strong></p>
<p>The <code>setupTests.ts</code> file is a special configuration file that Jest automatically loads before running any tests. Think of it as the &quot;preparation room&quot; that gets everything ready for your tests to run smoothly.</p>
<p><strong>🎯 The Problem It Solves:</strong></p>
<p>Imagine you're testing React components. By default, Jest comes with basic testing capabilities, but when testing web components, you need extra tools to check things like:</p>
<ul>
<li>&quot;Is this button actually visible on the page?&quot;</li>
<li>&quot;Does this input field have the right CSS class?&quot;</li>
<li>&quot;Is this error message showing up when it should?&quot;</li>
</ul>
<p><strong>🔧 What <code>setupTests.ts</code> Does:</strong></p>
<ol>
<li><strong>Enhanced Matchers</strong>: <code>@testing-library/jest-dom</code> provides additional Jest matchers specifically for DOM testing:</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment">// ❌ Without @testing-library/jest-dom - you'd have to write complex checks:</span>
<span class="hljs-keyword">const</span> button = screen.getByRole(<span class="hljs-string">'button'</span>);
expect(button.parentElement?.contains(button)).toBe(<span class="hljs-literal">true</span>); <span class="hljs-comment">// Hard to understand!</span>

<span class="hljs-comment">// ✅ With @testing-library/jest-dom - simple and readable:</span>
<span class="hljs-keyword">const</span> button = screen.getByRole(<span class="hljs-string">'button'</span>);
expect(button).toBeInTheDocument(); <span class="hljs-comment">// Clear and intuitive!</span>
</div></code></pre>
<p><strong>Available Enhanced Matchers:</strong></p>
<ul>
<li><code>toBeInTheDocument()</code> - checks if element exists in DOM</li>
<li><code>toHaveClass('my-class')</code> - checks if element has specific CSS class</li>
<li><code>toHaveAttribute('href', '/link')</code> - checks element attributes</li>
<li><code>toBeDisabled()</code> - checks if form elements are disabled</li>
<li><code>toBeVisible()</code> - checks if element is visible to users</li>
<li><code>toHaveTextContent('Hello')</code> - checks element's text content</li>
<li><code>toHaveValue('input value')</code> - checks form input values</li>
<li>And many more!</li>
</ul>
<ol start="2">
<li><strong>Browser API Mocking</strong>: We also mock <code>scrollIntoView</code> because:</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment">// The Problem: React components often use browser APIs</span>
<span class="hljs-keyword">const</span> scrollToBottom = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  messagesEndRef.current?.scrollIntoView({ behavior: <span class="hljs-string">'smooth'</span> });
};

<span class="hljs-comment">// But jsdom (testing environment) doesn't implement all browser APIs</span>
<span class="hljs-comment">// Without the mock: TypeError: scrollIntoView is not a function</span>
<span class="hljs-comment">// With the mock: Tests run smoothly! ✅</span>
</div></code></pre>
<ol start="3">
<li><strong>Global Test Setup</strong>: Any code here runs before each test file, perfect for:</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment">// Example of what you might add to setupTests.ts:</span>

<span class="hljs-comment">// Import the enhanced matchers</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'@testing-library/jest-dom'</span>;

<span class="hljs-comment">// Set up fake timers for all tests (if needed)</span>
beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  jest.useFakeTimers();
});

<span class="hljs-comment">// Clean up after each test</span>
afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  jest.useRealTimers();
  <span class="hljs-comment">// Clear any mocks</span>
  jest.clearAllMocks();
});

<span class="hljs-comment">// Mock setup (like our fetch mocks for API calls)</span>
<span class="hljs-comment">// Global configurations</span>
<span class="hljs-comment">// Custom matchers or utilities</span>
</div></code></pre>
<ol start="3">
<li><strong>TypeScript Support</strong>: Ensures TypeScript recognizes the new matcher types.</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment">// ❌ Without setupTests.ts - TypeScript Error:</span>
expect(button).toBeInTheDocument(); 
<span class="hljs-comment">// Error: Property 'toBeInTheDocument' does not exist on type 'Assertion'</span>

<span class="hljs-comment">// ✅ With setupTests.ts - TypeScript knows about the new matchers:</span>
expect(button).toBeInTheDocument(); <span class="hljs-comment">// ✓ Works perfectly!</span>
</div></code></pre>
<p><strong>🚨 What Happens Without This File:</strong></p>
<ol>
<li><strong>Limited Testing Capabilities</strong>: You'd only have basic Jest matchers</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment">// You'd be stuck with basic assertions like:</span>
expect(element.className).toContain(<span class="hljs-string">'active'</span>); <span class="hljs-comment">// Less readable</span>
<span class="hljs-comment">// Instead of:</span>
expect(element).toHaveClass(<span class="hljs-string">'active'</span>); <span class="hljs-comment">// Much clearer!</span>
</div></code></pre>
<ol start="2">
<li>
<p><strong>TypeScript Errors</strong>: Assertions like <code>expect(element).toBeInTheDocument()</code> would fail with TypeScript errors</p>
</li>
<li>
<p><strong>Repetitive Setup Code</strong>: You'd have to import and configure testing utilities in every test file</p>
</li>
</ol>
<p><strong>🎯 Real-World Example:</strong></p>
<p>Let's say you're testing a login form:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// In your test file - with setupTests.ts configured:</span>
it(<span class="hljs-string">'should show error message for invalid login'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  render(&lt;LoginForm /&gt;);
  
  <span class="hljs-keyword">const</span> usernameInput = screen.getByLabelText(<span class="hljs-string">'Username'</span>);
  <span class="hljs-keyword">const</span> submitButton = screen.getByRole(<span class="hljs-string">'button'</span>, { name: <span class="hljs-string">'Login'</span> });
  
  <span class="hljs-comment">// These enhanced matchers make tests much more readable:</span>
  expect(usernameInput).toBeInTheDocument();     <span class="hljs-comment">// Clear: element exists</span>
  expect(submitButton).toBeEnabled();            <span class="hljs-comment">// Clear: button is clickable</span>
  
  <span class="hljs-comment">// Submit empty form</span>
  fireEvent.click(submitButton);
  
  <span class="hljs-keyword">const</span> errorMessage = screen.getByText(<span class="hljs-string">'Username is required'</span>);
  expect(errorMessage).toBeVisible();            <span class="hljs-comment">// Clear: error is shown to user</span>
  expect(errorMessage).toHaveClass(<span class="hljs-string">'error'</span>);     <span class="hljs-comment">// Clear: has error styling</span>
});
</div></code></pre>
<p><strong>🔄 How Jest Uses This File:</strong></p>
<ol>
<li>Jest starts up</li>
<li>Jest automatically finds and runs <code>setupTests.ts</code></li>
<li>This imports all the enhanced matchers and sets up the environment</li>
<li>Jest then runs your actual test files</li>
<li>Your tests can now use all the enhanced matchers</li>
</ol>
<p><strong>💡 Key Takeaway:</strong></p>
<p>Think of <code>setupTests.ts</code> as your testing toolkit's instruction manual. It tells Jest: &quot;Hey, when you run tests, make sure you have these extra tools available!&quot; This way, every test file in your project automatically gets access to better, more readable testing utilities without having to import them individually.</p>
<h3 id="%E2%9C%85-step-4-verify-setup">✅ Step 4: Verify Setup</h3>
<pre class="hljs"><code><div><span class="hljs-comment"># Run the test command to ensure everything is configured</span>
npm <span class="hljs-built_in">test</span>
</div></code></pre>
<p><strong>Troubleshooting Common Issues:</strong></p>
<p>If you get <code>'jest' is not recognized</code> error:</p>
<ol>
<li>Make sure Jest is installed: <code>npm install --save-dev jest ts-jest @types/jest</code></li>
<li>Check that your <code>package.json</code> has the test script: <code>&quot;test&quot;: &quot;jest&quot;</code></li>
<li>Try running: <code>npx jest</code> instead of <code>npm test</code></li>
</ol>
<p>If you get module resolution errors:</p>
<ol>
<li>Ensure <code>jest.config.js</code> is in your project root</li>
<li>Check that <code>moduleNameMapper</code> is correctly configured for CSS imports</li>
<li>Verify TypeScript files are being transformed with <code>ts-jest</code></li>
</ol>
<p>If you get &quot;Unknown option&quot; validation warnings:</p>
<ol>
<li><strong>Common mistake</strong>: Using <code>moduleNameMapping</code> instead of <code>moduleNameMapper</code></li>
<li><strong>Fix</strong>: Change <code>moduleNameMapping:</code> to <code>moduleNameMapper:</code> in <code>jest.config.js</code></li>
<li><strong>Verify</strong>: The correct property name is <code>moduleNameMapper</code> (without 's' at the end)</li>
</ol>
<p>If you get &quot;No tests found&quot; (this is expected at this stage):</p>
<ol>
<li>This is normal - we haven't written any tests yet!</li>
<li>Use <code>npm test -- --passWithNoTests</code> to verify Jest configuration is working</li>
<li>Jest should exit with code 0 instead of code 1 when using this flag</li>
</ol>
<h2 id="tdd-fundamentals-red-green-refactor">TDD Fundamentals: Red-Green-Refactor</h2>
<p>Let's start with a simple example to understand the TDD cycle.</p>
<h3 id="%F0%9F%A7%AA-step-5-testing-a-simple-utility-function">🧪 Step 5: Testing a Simple Utility Function</h3>
<p><strong>🔴 RED: Write the failing test first</strong></p>
<p><strong>Code 5.1: Create messageUtils.test.ts</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🧪 Step 5: TDD Red Phase - Message Utils Test</span>
<span class="hljs-comment">// Import the function we want to test (doesn't exist yet - this will fail)</span>
<span class="hljs-keyword">import</span> { formatMessage } <span class="hljs-keyword">from</span> <span class="hljs-string">'../messageUtils'</span>;

<span class="hljs-comment">// Describe block groups related tests together</span>
describe(<span class="hljs-string">'formatMessage'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Individual test case using 'it' function</span>
  it(<span class="hljs-string">'should format a simple message'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Arrange: Set up test data</span>
    <span class="hljs-keyword">const</span> text = <span class="hljs-string">'Hello World'</span>;    <span class="hljs-comment">// Message text to format</span>
    <span class="hljs-keyword">const</span> sender = <span class="hljs-string">'user'</span>;         <span class="hljs-comment">// Who sent the message</span>
    
    <span class="hljs-comment">// Act: Call the function we're testing</span>
    <span class="hljs-keyword">const</span> result = formatMessage(text, sender);
    
    <span class="hljs-comment">// Assert: Check that the result matches our expectations</span>
    expect(result).toEqual({
      text: <span class="hljs-string">'Hello World'</span>,              <span class="hljs-comment">// Should preserve original text</span>
      sender: <span class="hljs-string">'user'</span>,                   <span class="hljs-comment">// Should preserve sender</span>
      timestamp: expect.any(<span class="hljs-built_in">Date</span>),      <span class="hljs-comment">// Should have a Date (any Date is fine)</span>
      id: expect.any(<span class="hljs-built_in">String</span>)            <span class="hljs-comment">// Should have a string ID (any string is fine)</span>
    });
  });
});
</div></code></pre>
<p><strong>Run the test - it should FAIL:</strong></p>
<pre class="hljs"><code><div>npm <span class="hljs-built_in">test</span>
<span class="hljs-comment"># Error: Cannot find module '../messageUtils'</span>
</div></code></pre>
<p><strong>🟢 GREEN: Write minimal code to make it pass</strong></p>
<p><strong>Code 5.2: Create messageUtils.ts</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🧪 Step 5: Message Utils Implementation (GREEN Phase)</span>
<span class="hljs-comment">// Define the TypeScript interface for our formatted message</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FormattedMessage {
  text: <span class="hljs-built_in">string</span>;      <span class="hljs-comment">// The message content</span>
  sender: <span class="hljs-built_in">string</span>;    <span class="hljs-comment">// Who sent it ('user' or 'bot')</span>
  timestamp: <span class="hljs-built_in">Date</span>;   <span class="hljs-comment">// When it was created</span>
  id: <span class="hljs-built_in">string</span>;        <span class="hljs-comment">// Unique identifier</span>
}

<span class="hljs-comment">// Function to format a message with metadata</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatMessage</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, sender: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">FormattedMessage</span> </span>{
  <span class="hljs-keyword">return</span> {
    text,                                    <span class="hljs-comment">// Keep original text</span>
    sender,                                  <span class="hljs-comment">// Keep original sender</span>
    timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),                   <span class="hljs-comment">// Add current timestamp</span>
    id: <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>)           <span class="hljs-comment">// Generate simple random ID</span>
  };
}
</div></code></pre>
<p><strong>Run the test - it should PASS:</strong></p>
<pre class="hljs"><code><div>npm <span class="hljs-built_in">test</span>
<span class="hljs-comment"># ✓ should format a simple message</span>
</div></code></pre>
<p><strong>🔵 REFACTOR: Improve the code - Detailed Explanation</strong></p>
<p>Now that our test is passing, we can safely improve the code quality without fear of breaking anything. This is the beauty of TDD - the test acts as a safety net!</p>
<p><strong>🤔 What's Wrong with Our Current Code?</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Current code - works but has problems:</span>
id: <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>)  <span class="hljs-comment">// Generates IDs like: "0.abc123"</span>
</div></code></pre>
<p><strong>Problems:</strong></p>
<ol>
<li><strong>Short IDs</strong>: Only ~7 characters, higher chance of duplicates</li>
<li><strong>Starts with &quot;0.&quot;</strong>: Always begins with zero and decimal point</li>
<li><strong>No timestamp</strong>: Can't tell when message was created from ID</li>
<li><strong>Collision risk</strong>: Two messages could get same ID (very rare but possible)</li>
</ol>
<p><strong>✨ Let's Make It Better:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Improved function with better ID generation</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatMessage</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, sender: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">FormattedMessage</span> </span>{
  <span class="hljs-keyword">return</span> {
    text,                                                           <span class="hljs-comment">// Keep original text</span>
    sender,                                                         <span class="hljs-comment">// Keep original sender</span>
    timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),                                          <span class="hljs-comment">// Add current timestamp</span>
    id: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)}</span>`</span> <span class="hljs-comment">// Better ID: timestamp + random string</span>
  };
}
</div></code></pre>
<p><strong>📋 Complete Final Code for messageUtils.ts:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🔧 Step 6: Message Utils Implementation (After TDD Refactor)</span>
<span class="hljs-comment">// Define the TypeScript interface for our formatted message</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FormattedMessage {
  text: <span class="hljs-built_in">string</span>;      <span class="hljs-comment">// The message content</span>
  sender: <span class="hljs-built_in">string</span>;    <span class="hljs-comment">// Who sent it ('user' or 'bot')</span>
  timestamp: <span class="hljs-built_in">Date</span>;   <span class="hljs-comment">// When it was created</span>
  id: <span class="hljs-built_in">string</span>;        <span class="hljs-comment">// Unique identifier</span>
}

<span class="hljs-comment">// Improved function with better ID generation</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatMessage</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, sender: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">FormattedMessage</span> </span>{
  <span class="hljs-keyword">return</span> {
    text,                                                          <span class="hljs-comment">// Keep original text</span>
    sender,                                                        <span class="hljs-comment">// Keep original sender</span>
    timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),                                         <span class="hljs-comment">// Add current timestamp</span>
    id: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)}</span>`</span> <span class="hljs-comment">// Better ID: timestamp + random string</span>
  };
}
</div></code></pre>
<pre class="hljs"><code><div>
**🔍 Breaking Down the Improved ID Generation:**

```typescript
// Let's understand this piece by piece:
`${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

// Part 1: Date.now()
Date.now()  // Returns: 1693737600000 (current timestamp in milliseconds)

// Part 2: Math.random().toString(36).substr(2, 9)
Math.random()           // Returns: 0.abc123def456  (random decimal)
.toString(36)           // Converts to: &quot;0.abc123def456&quot; (base 36: 0-9, a-z)
.substr(2, 9)           // Extracts: &quot;abc123def&quot; (skip &quot;0.&quot;, take 9 chars)

// Combined result:
&quot;1693737600000-abc123def&quot;  // Timestamp + dash + random string
</div></code></pre>
<p><strong>🎯 Why This is Better:</strong></p>
<ol>
<li><strong>Uniqueness</strong>: Timestamp ensures no two messages at different times can have same ID</li>
<li><strong>Readable</strong>: Can see when message was created (1693737600000 = specific millisecond)</li>
<li><strong>Longer</strong>: 13+ characters instead of ~7, much lower collision risk</li>
<li><strong>Debuggable</strong>: When debugging, you can tell message order by timestamp</li>
<li><strong>No leading zeros</strong>: Starts with meaningful timestamp</li>
</ol>
<p><strong>🧪 The Refactor Safety Check:</strong></p>
<pre class="hljs"><code><div>npm <span class="hljs-built_in">test</span>
<span class="hljs-comment"># ✓ should format a simple message</span>
</div></code></pre>
<p><strong>✅ Test still passes!</strong> This confirms our refactor didn't break existing functionality.</p>
<p><strong>💡 Key Refactor Principle:</strong></p>
<blockquote>
<p>&quot;Make the code better while keeping the exact same behavior&quot;</p>
</blockquote>
<p>The test ensures we didn't accidentally:</p>
<ul>
<li>Change what the function returns</li>
<li>Break the interface</li>
<li>Introduce new bugs</li>
</ul>
<h3 id="%F0%9F%94%84-step-6-tdd-strategies---triangulation">🔄 Step 6: TDD Strategies - Triangulation</h3>
<p><strong>1. Faking It:</strong>
Start with the simplest implementation, even hardcoded values.</p>
<p><strong>2. Obvious Implementation:</strong>
If the solution is clear, implement it directly.</p>
<p><strong>3. Triangulation:</strong>
Add more tests to drive out generalization.</p>
<p>Let's add more tests to triangulate:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Test suite for formatMessage function with multiple test cases</span>
describe(<span class="hljs-string">'formatMessage'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Test 1: Basic functionality</span>
  it(<span class="hljs-string">'should format a simple message'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> text = <span class="hljs-string">'Hello World'</span>;
    <span class="hljs-keyword">const</span> sender = <span class="hljs-string">'user'</span>;
    
    <span class="hljs-keyword">const</span> result = formatMessage(text, sender);
    
    <span class="hljs-comment">// Verify all expected properties are present and correct</span>
    expect(result).toEqual({
      text: <span class="hljs-string">'Hello World'</span>,              <span class="hljs-comment">// Text should be preserved exactly</span>
      sender: <span class="hljs-string">'user'</span>,                   <span class="hljs-comment">// Sender should be preserved exactly</span>
      timestamp: expect.any(<span class="hljs-built_in">Date</span>),      <span class="hljs-comment">// Should have a timestamp (any Date)</span>
      id: expect.any(<span class="hljs-built_in">String</span>)            <span class="hljs-comment">// Should have an ID (any string)</span>
    });
  });

  <span class="hljs-comment">// Test 2: Different sender type (triangulation)</span>
  it(<span class="hljs-string">'should format bot messages differently'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> text = <span class="hljs-string">'How can I help?'</span>;
    <span class="hljs-keyword">const</span> sender = <span class="hljs-string">'bot'</span>;              <span class="hljs-comment">// Testing with 'bot' instead of 'user'</span>
    
    <span class="hljs-keyword">const</span> result = formatMessage(text, sender);
    
    <span class="hljs-comment">// Check specific properties individually</span>
    expect(result.sender).toBe(<span class="hljs-string">'bot'</span>);           <span class="hljs-comment">// Should preserve 'bot' sender</span>
    expect(result.text).toBe(<span class="hljs-string">'How can I help?'</span>); <span class="hljs-comment">// Should preserve bot text</span>
  });

  <span class="hljs-comment">// Test 3: Uniqueness requirement (triangulation)</span>
  it(<span class="hljs-string">'should generate unique IDs for each message'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Create two messages with same content</span>
    <span class="hljs-keyword">const</span> message1 = formatMessage(<span class="hljs-string">'First'</span>, <span class="hljs-string">'user'</span>);
    <span class="hljs-keyword">const</span> message2 = formatMessage(<span class="hljs-string">'Second'</span>, <span class="hljs-string">'user'</span>);
    
    <span class="hljs-comment">// IDs should be different even for similar messages</span>
    expect(message1.id).not.toBe(message2.id);
  });
});
</div></code></pre>
<h2 id="building-our-chatbot-with-tdd">Building Our Chatbot with TDD</h2>
<p>Now let's build our chatbot application using TDD. We'll start with the smallest pieces and build up.</p>
<h3 id="%F0%9F%93%9D-step-7-message-types-inside-out-approach">📝 Step 7: Message Types (Inside-Out Approach)</h3>
<p><strong>🔴 RED: Test the Message interface</strong></p>
<p><strong>Code 7.1: Create Message.test.ts</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 📝 Step 7: Message Types Test (Inside-Out Approach)</span>
<span class="hljs-comment">// Import the types and functions we want to test</span>
<span class="hljs-keyword">import</span> { Message, isValidMessage } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Message'</span>;

<span class="hljs-comment">// Test suite for Message type and validation</span>
describe(<span class="hljs-string">'Message'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Test 1: Valid message should pass validation</span>
  it(<span class="hljs-string">'should validate a correct message'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Create a properly formatted message object</span>
    <span class="hljs-keyword">const</span> message: Message = {
      id: <span class="hljs-string">'test-id'</span>,               <span class="hljs-comment">// Unique identifier</span>
      text: <span class="hljs-string">'Hello'</span>,               <span class="hljs-comment">// Message content</span>
      sender: <span class="hljs-string">'user'</span>,              <span class="hljs-comment">// Must be 'user' or 'bot'</span>
      timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()        <span class="hljs-comment">// Creation time</span>
    };

    <span class="hljs-comment">// Should return true for valid message</span>
    expect(isValidMessage(message)).toBe(<span class="hljs-literal">true</span>);
  });

  <span class="hljs-comment">// Test 2: Invalid message with empty text should fail</span>
  it(<span class="hljs-string">'should reject message with empty text'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Create message with empty text (invalid)</span>
    <span class="hljs-keyword">const</span> message = {
      id: <span class="hljs-string">'test-id'</span>,
      text: <span class="hljs-string">''</span>,                    <span class="hljs-comment">// Empty text should be invalid</span>
      sender: <span class="hljs-string">'user'</span>,
      timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
    };

    <span class="hljs-comment">// Should return false for invalid message</span>
    expect(isValidMessage(message)).toBe(<span class="hljs-literal">false</span>);
  });

  <span class="hljs-comment">// Test 3: Invalid sender should fail validation</span>
  it(<span class="hljs-string">'should reject message with invalid sender'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Create message with invalid sender</span>
    <span class="hljs-keyword">const</span> message = {
      id: <span class="hljs-string">'test-id'</span>,
      text: <span class="hljs-string">'Hello'</span>,
      sender: <span class="hljs-string">'invalid'</span>,           <span class="hljs-comment">// Not 'user' or 'bot' - invalid</span>
      timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
    };

    <span class="hljs-comment">// Should return false for invalid sender</span>
    expect(isValidMessage(message)).toBe(<span class="hljs-literal">false</span>);
  });
});
</div></code></pre>
<p><strong>🟢 GREEN: Implement the Message type</strong></p>
<p><strong>Create <code>src/types/Message.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 📝 Step 7: Message Types Implementation (GREEN Phase)</span>
<span class="hljs-comment">// Define the TypeScript interface for a chat message</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Message {
  id: <span class="hljs-built_in">string</span>;                    <span class="hljs-comment">// Unique identifier for the message</span>
  text: <span class="hljs-built_in">string</span>;                  <span class="hljs-comment">// The actual message content</span>
  sender: <span class="hljs-string">'user'</span> | <span class="hljs-string">'bot'</span>;        <span class="hljs-comment">// Union type: only 'user' or 'bot' allowed</span>
  timestamp: <span class="hljs-built_in">Date</span>;               <span class="hljs-comment">// When the message was created</span>
}

<span class="hljs-comment">// Type guard function to validate if an object is a valid Message</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidMessage</span>(<span class="hljs-params">message: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">message</span> <span class="hljs-title">is</span> <span class="hljs-title">Message</span> </span>{
  <span class="hljs-keyword">return</span> (
    <span class="hljs-keyword">typeof</span> message === <span class="hljs-string">'object'</span> &amp;&amp;                                    <span class="hljs-comment">// Must be an object</span>
    <span class="hljs-keyword">typeof</span> message.id === <span class="hljs-string">'string'</span> &amp;&amp;                                 <span class="hljs-comment">// ID must be string</span>
    <span class="hljs-keyword">typeof</span> message.text === <span class="hljs-string">'string'</span> &amp;&amp;                               <span class="hljs-comment">// Text must be string</span>
    message.text.length &gt; <span class="hljs-number">0</span> &amp;&amp;                                        <span class="hljs-comment">// Text cannot be empty</span>
    (message.sender === <span class="hljs-string">'user'</span> || message.sender === <span class="hljs-string">'bot'</span>) &amp;&amp;        <span class="hljs-comment">// Sender must be 'user' or 'bot'</span>
    message.timestamp <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>                                  <span class="hljs-comment">// Timestamp must be Date object</span>
  );
}
</div></code></pre>
<h3 id="%F0%9F%A4%96-step-8-bot-response-logic">🤖 Step 8: Bot Response Logic</h3>
<p><strong>Create:</strong> <code>src/services/__tests__/botService.test.ts</code></p>
<p><strong>🔴 RED: Test the bot response function</strong></p>
<p><strong>Create <code>src/services/__tests__/botService.test.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🤖 Step 8: Bot Response Logic Tests</span>
<span class="hljs-comment">// Import the function we want to test</span>
<span class="hljs-keyword">import</span> { getBotResponse } <span class="hljs-keyword">from</span> <span class="hljs-string">'../botService'</span>;

<span class="hljs-comment">// Test suite for bot response service</span>
describe(<span class="hljs-string">'botService'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Nested describe for organizing getBotResponse tests</span>
  describe(<span class="hljs-string">'getBotResponse'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Test 1: Bot should respond to "hello"</span>
    it(<span class="hljs-string">'should respond to hello'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> response = getBotResponse(<span class="hljs-string">'hello'</span>);
      <span class="hljs-comment">// Response text should contain "Hello" (case-insensitive check)</span>
      expect(response.text).toContain(<span class="hljs-string">'Hello'</span>);
    });

    <span class="hljs-comment">// Test 2: Bot should respond to "hi" similarly</span>
    it(<span class="hljs-string">'should respond to hi'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> response = getBotResponse(<span class="hljs-string">'hi'</span>);
      <span class="hljs-comment">// Both "hello" and "hi" should get Hello response</span>
      expect(response.text).toContain(<span class="hljs-string">'Hello'</span>);
    });

    <span class="hljs-comment">// Test 3: Bot should handle different cases</span>
    it(<span class="hljs-string">'should be case insensitive'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> response = getBotResponse(<span class="hljs-string">'HELLO'</span>);  <span class="hljs-comment">// Test uppercase input</span>
      <span class="hljs-comment">// Should still respond with Hello regardless of input case</span>
      expect(response.text).toContain(<span class="hljs-string">'Hello'</span>);
    });

    <span class="hljs-comment">// Test 4: Bot should respond to vite-related questions</span>
    it(<span class="hljs-string">'should respond to vite questions'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> response = getBotResponse(<span class="hljs-string">'tell me about vite'</span>);
      <span class="hljs-comment">// Response should mention vite (convert to lowercase for case-insensitive check)</span>
      expect(response.text.toLowerCase()).toContain(<span class="hljs-string">'vite'</span>);
    });

    <span class="hljs-comment">// Test 5: Bot should have default response for unknown inputs</span>
    it(<span class="hljs-string">'should have a default response for unknown inputs'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> response = getBotResponse(<span class="hljs-string">'xyz123'</span>);  <span class="hljs-comment">// Random input</span>
      <span class="hljs-comment">// Should have some response (not empty)</span>
      expect(response.text).toBeDefined();
      expect(response.text.length).toBeGreaterThan(<span class="hljs-number">0</span>);
    });

    <span class="hljs-comment">// Test 6: Response should include delay for realistic chat experience</span>
    it(<span class="hljs-string">'should return response with delay'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> response = getBotResponse(<span class="hljs-string">'hello'</span>);
      <span class="hljs-comment">// Delay should be reasonable (&gt; 0 but &lt; 3 seconds)</span>
      expect(response.delay).toBeGreaterThan(<span class="hljs-number">0</span>);
      expect(response.delay).toBeLessThan(<span class="hljs-number">3000</span>);
    });
  });
});
</div></code></pre>
<p><strong>🟢 GREEN: Implement the bot service</strong></p>
<p><strong>Create <code>src/services/botService.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🤖 Step 8: Bot Service Implementation (GREEN Phase)</span>
<span class="hljs-comment">// Define the interface for bot responses</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> BotResponse {
  text: <span class="hljs-built_in">string</span>;    <span class="hljs-comment">// The response message</span>
  delay: <span class="hljs-built_in">number</span>;   <span class="hljs-comment">// Milliseconds to wait before showing response</span>
}

<span class="hljs-comment">// Main function to generate bot responses based on user input</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBotResponse</span>(<span class="hljs-params">userMessage: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">BotResponse</span> </span>{
  <span class="hljs-comment">// Normalize input: convert to lowercase and remove whitespace</span>
  <span class="hljs-keyword">const</span> message = userMessage.toLowerCase().trim();
  
  <span class="hljs-comment">// Check for greeting keywords</span>
  <span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">'hello'</span>) || message.includes(<span class="hljs-string">'hi'</span>)) {
    <span class="hljs-keyword">return</span> {
      text: <span class="hljs-string">"Hello! I'm a TDD-built chatbot. How can I help you today?"</span>,
      delay: <span class="hljs-number">1000</span>    <span class="hljs-comment">// 1 second delay</span>
    };
  }
  
  <span class="hljs-comment">// Check for vite-related questions</span>
  <span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">'vite'</span>)) {
    <span class="hljs-keyword">return</span> {
      text: <span class="hljs-string">"Vite is amazing! ⚡ Super fast development and builds. This bot was built using TDD!"</span>,
      delay: <span class="hljs-number">800</span>     <span class="hljs-comment">// Slightly faster response</span>
    };
  }
  
  <span class="hljs-comment">// Check for react-related questions</span>
  <span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">'react'</span>)) {
    <span class="hljs-keyword">return</span> {
      text: <span class="hljs-string">"React with TypeScript is powerful! And with TDD, we build it right the first time. 🚀"</span>,
      delay: <span class="hljs-number">1200</span>    <span class="hljs-comment">// Slightly longer response</span>
    };
  }
  
  <span class="hljs-comment">// Check for goodbye</span>
  <span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">'bye'</span>)) {
    <span class="hljs-keyword">return</span> {
      text: <span class="hljs-string">"Goodbye! Thanks for trying this TDD-built chatbot! 👋"</span>,
      delay: <span class="hljs-number">600</span>     <span class="hljs-comment">// Quick goodbye</span>
    };
  }
  
  <span class="hljs-comment">// Default response for unrecognized input</span>
  <span class="hljs-keyword">return</span> {
    text: <span class="hljs-string">`You said: "<span class="hljs-subst">${userMessage}</span>". This response was generated by TDD-tested code! ⚡`</span>,
    delay: <span class="hljs-number">1000</span>    <span class="hljs-comment">// Standard delay</span>
  };
}
</div></code></pre>
<p><strong>🔵 REFACTOR: Extract response patterns - Newbie-Friendly Explanation</strong></p>
<p>Our tests are passing, but the current code has problems. Let's improve it!</p>
<p><strong>🤔 What's Wrong with Our Current botService Code?</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Current code works but is messy:</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBotResponse</span>(<span class="hljs-params">userMessage: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">BotResponse</span> </span>{
  <span class="hljs-keyword">const</span> message = userMessage.toLowerCase().trim();
  
  <span class="hljs-comment">// Repeated if-statements - hard to maintain</span>
  <span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">'hello'</span>) || message.includes(<span class="hljs-string">'hi'</span>)) {
    <span class="hljs-keyword">return</span> { text: <span class="hljs-string">"Hello! I'm a TDD-built chatbot..."</span>, delay: <span class="hljs-number">1000</span> };
  }
  <span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">'vite'</span>)) {
    <span class="hljs-keyword">return</span> { text: <span class="hljs-string">"Vite is amazing! ⚡..."</span>, delay: <span class="hljs-number">800</span> };
  }
  <span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">'react'</span>)) {
    <span class="hljs-keyword">return</span> { text: <span class="hljs-string">"React with TypeScript..."</span>, delay: <span class="hljs-number">1200</span> };
  }
  <span class="hljs-comment">// ... more if statements</span>
}
</div></code></pre>
<p><strong>Problems:</strong></p>
<ol>
<li><strong>Code Duplication</strong>: Each if-statement follows same pattern</li>
<li><strong>Hard to Maintain</strong>: Adding new responses means more if-statements</li>
<li><strong>Hard to Test</strong>: Each response is embedded in the logic</li>
<li><strong>No Organization</strong>: Responses scattered throughout the function</li>
</ol>
<p><strong>✨ Let's Refactor - Step by Step:</strong></p>
<p><strong>Step 1: Extract Response Data</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Before: Responses mixed with logic</span>
<span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">'hello'</span>)) {
  <span class="hljs-keyword">return</span> { text: <span class="hljs-string">"Hello! I'm a chatbot..."</span>, delay: <span class="hljs-number">1000</span> };
}

<span class="hljs-comment">// After: Separate data from logic</span>
<span class="hljs-keyword">const</span> responsePatterns = [
  {
    keywords: [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hi'</span>],
    response: <span class="hljs-string">"Hello! I'm a TDD-built chatbot. How can I help you today?"</span>,
    delay: <span class="hljs-number">1000</span>
  }
];
</div></code></pre>
<p><strong>Step 2: Create Data Structure</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Define structure for response patterns (makes it easier to add new responses)</span>
<span class="hljs-keyword">interface</span> ResponsePattern {
  keywords: <span class="hljs-built_in">string</span>[];    <span class="hljs-comment">// Array of trigger words</span>
  response: <span class="hljs-built_in">string</span>;      <span class="hljs-comment">// What to respond with  </span>
  delay: <span class="hljs-built_in">number</span>;         <span class="hljs-comment">// How long to wait before responding</span>
}

<span class="hljs-comment">// Configuration array of all possible responses (easy to maintain and extend)</span>
<span class="hljs-keyword">const</span> responsePatterns: ResponsePattern[] = [
  {
    keywords: [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hi'</span>],  <span class="hljs-comment">// Greeting keywords</span>
    response: <span class="hljs-string">"Hello! I'm a TDD-built chatbot. How can I help you today?"</span>,
    delay: <span class="hljs-number">1000</span>                 <span class="hljs-comment">// 1 second delay</span>
  },
  {
    keywords: [<span class="hljs-string">'vite'</span>],         <span class="hljs-comment">// Vite-related keywords</span>
    response: <span class="hljs-string">"Vite is amazing! ⚡ Super fast development and builds. This bot was built using TDD!"</span>,
    delay: <span class="hljs-number">800</span>                  <span class="hljs-comment">// Faster response for tech topics</span>
  },
  {
    keywords: [<span class="hljs-string">'react'</span>],        <span class="hljs-comment">// React-related keywords</span>
    response: <span class="hljs-string">"React with TypeScript is powerful! And with TDD, we build it right the first time. 🚀"</span>,
    delay: <span class="hljs-number">1200</span>                 <span class="hljs-comment">// Slightly longer for detailed tech response</span>
  },
  {
    keywords: [<span class="hljs-string">'bye'</span>],          <span class="hljs-comment">// Farewell keywords</span>
    response: <span class="hljs-string">"Goodbye! Thanks for trying this TDD-built chatbot! 👋"</span>,
    delay: <span class="hljs-number">600</span>                  <span class="hljs-comment">// Quick goodbye</span>
  }
];
</div></code></pre>
<p><strong>Step 3: Simplify the Logic</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Improved bot response function using pattern matching</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBotResponse</span>(<span class="hljs-params">userMessage: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">BotResponse</span> </span>{
  <span class="hljs-comment">// Normalize input: convert to lowercase and remove whitespace</span>
  <span class="hljs-keyword">const</span> message = userMessage.toLowerCase().trim();
  
  <span class="hljs-comment">// Find the first pattern that matches any keyword in the user message</span>
  <span class="hljs-keyword">const</span> pattern = responsePatterns.find(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> 
    p.keywords.some(<span class="hljs-function"><span class="hljs-params">keyword</span> =&gt;</span> message.includes(keyword))  <span class="hljs-comment">// Check if any keyword is found</span>
  );
  
  <span class="hljs-comment">// If we found a matching pattern, use it</span>
  <span class="hljs-keyword">if</span> (pattern) {
    <span class="hljs-keyword">return</span> {
      text: pattern.response,
      delay: pattern.delay
    };
  }
  
  <span class="hljs-comment">// Default response if no patterns match</span>
  <span class="hljs-keyword">return</span> {
    text: <span class="hljs-string">`You said: "<span class="hljs-subst">${userMessage}</span>". This response was generated by TDD-tested code! ⚡`</span>,
    delay: <span class="hljs-number">1000</span>
  };
}
</div></code></pre>
<p><strong>📋 Complete Final Code for botService.ts:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🤖 Step 8: Bot Service Implementation (After TDD Refactor)</span>
<span class="hljs-comment">// Refactored version with extracted response patterns</span>

<span class="hljs-comment">// Define the interface for bot responses</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> BotResponse {
  text: <span class="hljs-built_in">string</span>;    <span class="hljs-comment">// The response message</span>
  delay: <span class="hljs-built_in">number</span>;   <span class="hljs-comment">// Milliseconds to wait before showing response</span>
}

<span class="hljs-comment">// Define structure for response patterns (makes it easier to add new responses)</span>
<span class="hljs-keyword">interface</span> ResponsePattern {
  keywords: <span class="hljs-built_in">string</span>[];    <span class="hljs-comment">// Array of trigger words</span>
  response: <span class="hljs-built_in">string</span>;      <span class="hljs-comment">// What to respond with</span>
  delay: <span class="hljs-built_in">number</span>;         <span class="hljs-comment">// How long to wait before responding</span>
}

<span class="hljs-comment">// Configuration array of all possible responses (easy to maintain and extend)</span>
<span class="hljs-keyword">const</span> responsePatterns: ResponsePattern[] = [
  {
    keywords: [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hi'</span>],  <span class="hljs-comment">// Greeting keywords</span>
    response: <span class="hljs-string">"Hello! I'm a TDD-built chatbot. How can I help you today?"</span>,
    delay: <span class="hljs-number">1000</span>                 <span class="hljs-comment">// 1 second delay</span>
  },
  {
    keywords: [<span class="hljs-string">'vite'</span>],         <span class="hljs-comment">// Vite-related keywords</span>
    response: <span class="hljs-string">"Vite is amazing! ⚡ Super fast development and builds. This bot was built using TDD!"</span>,
    delay: <span class="hljs-number">800</span>                  <span class="hljs-comment">// Faster response for tech topics</span>
  },
  {
    keywords: [<span class="hljs-string">'react'</span>],        <span class="hljs-comment">// React-related keywords</span>
    response: <span class="hljs-string">"React with TypeScript is powerful! And with TDD, we build it right the first time. 🚀"</span>,
    delay: <span class="hljs-number">1200</span>                 <span class="hljs-comment">// Slightly longer for detailed tech response</span>
  },
  {
    keywords: [<span class="hljs-string">'bye'</span>],          <span class="hljs-comment">// Farewell keywords</span>
    response: <span class="hljs-string">"Goodbye! Thanks for trying this TDD-built chatbot! 👋"</span>,
    delay: <span class="hljs-number">600</span>                  <span class="hljs-comment">// Quick goodbye</span>
  }
];

<span class="hljs-comment">// Improved bot response function using pattern matching</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBotResponse</span>(<span class="hljs-params">userMessage: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">BotResponse</span> </span>{
  <span class="hljs-comment">// Normalize input: convert to lowercase and remove whitespace</span>
  <span class="hljs-keyword">const</span> message = userMessage.toLowerCase().trim();
  
  <span class="hljs-comment">// Find the first pattern that matches any keyword in the user message</span>
  <span class="hljs-keyword">const</span> pattern = responsePatterns.find(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> 
    p.keywords.some(<span class="hljs-function"><span class="hljs-params">keyword</span> =&gt;</span> message.includes(keyword))  <span class="hljs-comment">// Check if any keyword is found</span>
  );
  
  <span class="hljs-comment">// If we found a matching pattern, use it</span>
  <span class="hljs-keyword">if</span> (pattern) {
    <span class="hljs-keyword">return</span> {
      text: pattern.response,
      delay: pattern.delay
    };
  }
  
  <span class="hljs-comment">// Default response if no patterns match</span>
  <span class="hljs-keyword">return</span> {
    text: <span class="hljs-string">`You said: "<span class="hljs-subst">${userMessage}</span>". This response was generated by TDD-tested code! ⚡`</span>,
    delay: <span class="hljs-number">1000</span>
  };
}
</div></code></pre>
<p><strong>🔍 Understanding the New Logic:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Let's break down this line:</span>
<span class="hljs-keyword">const</span> pattern = responsePatterns.find(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> 
  p.keywords.some(<span class="hljs-function"><span class="hljs-params">keyword</span> =&gt;</span> message.includes(keyword))
);

<span class="hljs-comment">// Step by step:</span>
<span class="hljs-comment">// 1. responsePatterns.find() - Look through all patterns</span>
<span class="hljs-comment">// 2. p.keywords.some() - Check if ANY keyword in the pattern matches</span>
<span class="hljs-comment">// 3. message.includes(keyword) - Does user message contain this keyword?</span>
<span class="hljs-comment">// 4. Returns first matching pattern or undefined</span>
</div></code></pre>
<p><strong>🎯 Why This Refactor is Amazing:</strong></p>
<p><strong>1. Easy to Add New Responses:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Just add to the array - no code changes needed!</span>
{
  keywords: [<span class="hljs-string">'typescript'</span>, <span class="hljs-string">'ts'</span>],
  response: <span class="hljs-string">"TypeScript adds type safety to JavaScript! 🔒"</span>,
  delay: <span class="hljs-number">900</span>
}
</div></code></pre>
<p><strong>2. Easy to Modify Existing Responses:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Change just the data, not the logic</span>
{
  keywords: [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hi'</span>, <span class="hljs-string">'hey'</span>, <span class="hljs-string">'greetings'</span>], <span class="hljs-comment">// Add more keywords</span>
  response: <span class="hljs-string">"Hello there! 👋"</span>,                   <span class="hljs-comment">// Update response</span>
  delay: <span class="hljs-number">500</span>                                     <span class="hljs-comment">// Change delay</span>
}
</div></code></pre>
<p><strong>3. Testable Separately:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Can test data separately from logic</span>
expect(responsePatterns[<span class="hljs-number">0</span>].keywords).toContain(<span class="hljs-string">'hello'</span>);
expect(responsePatterns[<span class="hljs-number">0</span>].delay).toBe(<span class="hljs-number">1000</span>);
</div></code></pre>
<p><strong>4. No Code Duplication:</strong></p>
<ul>
<li>One function handles all pattern matching</li>
<li>Adding responses = adding data, not code</li>
</ul>
<p><strong>🧪 Verify Our Refactor:</strong></p>
<pre class="hljs"><code><div>npm <span class="hljs-built_in">test</span>
<span class="hljs-comment"># ✓ All tests still pass!</span>
</div></code></pre>
<p><strong>💡 Key Takeaway:</strong></p>
<blockquote>
<p>&quot;Separate data from logic&quot; - Store configuration in arrays/objects, keep logic generic</p>
</blockquote>
<p>This makes code:</p>
<ul>
<li><strong>Easier to maintain</strong> (change data, not code)</li>
<li><strong>More flexible</strong> (add features by adding data)</li>
<li><strong>More testable</strong> (test data and logic separately)</li>
</ul>
<h3 id="%F0%9F%AA%9D-step-9-message-creation-hook">🪝 Step 9: Message Creation Hook</h3>
<p><strong>🤔 What is a Hook?</strong></p>
<p>A <strong>Hook</strong> in React is like a special tool that lets you &quot;hook into&quot; React's power. Think of it like this:</p>
<p><strong>🏠 Real-World Analogy:</strong></p>
<ul>
<li>Your house (component) needs electricity (state/logic)</li>
<li>Instead of building a power plant in every room, you &quot;hook into&quot; the main electrical system</li>
<li>Hooks let components &quot;plug into&quot; React's built-in features</li>
</ul>
<p><strong>🔌 What Hooks Do:</strong></p>
<ol>
<li><strong>useState</strong> → Gives your component memory (remembers things)</li>
<li><strong>useEffect</strong> → Lets your component do things when stuff changes</li>
<li><strong>Custom Hooks</strong> (like our <code>useMessages</code>) → Bundle up complex logic for reuse</li>
</ol>
<p><strong>💡 Why Use Custom Hooks?</strong></p>
<p><strong>❌ Without Custom Hook (messy):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Every component that needs messages has to write this:</span>
<span class="hljs-keyword">const</span> [messages, setMessages] = useState([]);
<span class="hljs-keyword">const</span> addMessage = <span class="hljs-function">(<span class="hljs-params">text, sender</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> newMessage = {
    id: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)}</span>`</span>,
    text, sender, timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
  };
  setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, newMessage]);
};
<span class="hljs-comment">// Copy this code everywhere = BAD! 😱</span>
</div></code></pre>
<p><strong>✅ With Custom Hook (clean):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Just one line in any component:</span>
<span class="hljs-keyword">const</span> { messages, addMessage } = useMessages();
<span class="hljs-comment">// Logic is centralized = GOOD! 🎉</span>
</div></code></pre>
<p><strong>🎯 Benefits of Custom Hooks:</strong></p>
<ul>
<li><strong>DRY Principle</strong>: Don't Repeat Yourself - write once, use everywhere</li>
<li><strong>Testing</strong>: Test the hook logic separately from UI</li>
<li><strong>Reusability</strong>: Any component can use message functionality</li>
<li><strong>Maintainability</strong>: Fix bugs in one place, affects all components</li>
<li><strong>Separation of Concerns</strong>: UI components focus on display, hooks handle logic</li>
</ul>
<p><strong>📝 Hook Rules (Important!):</strong></p>
<ol>
<li>Always start with <code>use</code> (naming convention)</li>
<li>Only call hooks at the top level (not in loops/conditions)</li>
<li>Only call from React components or other custom hooks</li>
</ol>
<p>Now let's build our custom <code>useMessages</code> hook using TDD!</p>
<p><strong>Create:</strong> <code>src/hooks/__tests__/useMessages.test.ts</code></p>
<p><strong>🔴 RED: Test the custom hook</strong></p>
<p><strong>Create <code>src/hooks/__tests__/useMessages.test.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🪝 Step 9: Message Creation Hook Tests</span>
<span class="hljs-comment">// Import React Testing Library utilities for testing hooks</span>
<span class="hljs-keyword">import</span> { renderHook, act } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-comment">// Import the custom hook we want to test</span>
<span class="hljs-keyword">import</span> { useMessages } <span class="hljs-keyword">from</span> <span class="hljs-string">'../useMessages'</span>;

<span class="hljs-comment">// Test suite for the useMessages hook</span>
describe(<span class="hljs-string">'useMessages'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Test 1: Check that the hook initializes with empty state</span>
  it(<span class="hljs-string">'should initialize with empty messages'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Render the hook in isolation</span>
    <span class="hljs-keyword">const</span> { result } = renderHook(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> useMessages());
    
    <span class="hljs-comment">// Assert that messages array starts empty</span>
    expect(result.current.messages).toEqual([]);
  });

  <span class="hljs-comment">// Test 2: Verify we can add user messages correctly</span>
  it(<span class="hljs-string">'should add a user message'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Render the hook</span>
    <span class="hljs-keyword">const</span> { result } = renderHook(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> useMessages());
    
    <span class="hljs-comment">// Use act() to wrap state updates for proper testing</span>
    act(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-comment">// Add a user message using the hook's function</span>
      result.current.addMessage(<span class="hljs-string">'Hello'</span>, <span class="hljs-string">'user'</span>);
    });
    
    <span class="hljs-comment">// Check that one message was added</span>
    expect(result.current.messages).toHaveLength(<span class="hljs-number">1</span>);
    <span class="hljs-comment">// Verify the message text is correct</span>
    expect(result.current.messages[<span class="hljs-number">0</span>].text).toBe(<span class="hljs-string">'Hello'</span>);
    <span class="hljs-comment">// Verify the sender is set correctly</span>
    expect(result.current.messages[<span class="hljs-number">0</span>].sender).toBe(<span class="hljs-string">'user'</span>);
  });

  <span class="hljs-comment">// Test 3: Verify we can add bot messages correctly</span>
  it(<span class="hljs-string">'should add a bot message'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Render the hook</span>
    <span class="hljs-keyword">const</span> { result } = renderHook(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> useMessages());
    
    <span class="hljs-comment">// Add a bot message</span>
    act(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      result.current.addMessage(<span class="hljs-string">'Hi there'</span>, <span class="hljs-string">'bot'</span>);
    });
    
    <span class="hljs-comment">// Verify one message was added with correct sender</span>
    expect(result.current.messages).toHaveLength(<span class="hljs-number">1</span>);
    expect(result.current.messages[<span class="hljs-number">0</span>].sender).toBe(<span class="hljs-string">'bot'</span>);
  });

  <span class="hljs-comment">// Test 4: Ensure each message gets a unique identifier</span>
  it(<span class="hljs-string">'should generate unique IDs for messages'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Render the hook</span>
    <span class="hljs-keyword">const</span> { result } = renderHook(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> useMessages());
    
    <span class="hljs-comment">// Add two messages</span>
    act(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      result.current.addMessage(<span class="hljs-string">'First'</span>, <span class="hljs-string">'user'</span>);
      result.current.addMessage(<span class="hljs-string">'Second'</span>, <span class="hljs-string">'user'</span>);
    });
    
    <span class="hljs-comment">// Verify that the IDs are different (important for React keys)</span>
    expect(result.current.messages[<span class="hljs-number">0</span>].id).not.toBe(result.current.messages[<span class="hljs-number">1</span>].id);
  });
});
</div></code></pre>
<p><strong>🟢 GREEN: Implement the hook</strong></p>
<p><strong>Create <code>src/hooks/useMessages.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🪝 Step 9: useMessages Hook Implementation (GREEN Phase)</span>
<span class="hljs-comment">// Import React's useState hook for managing component state</span>
<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-comment">// Import our Message type for type safety</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { Message } <span class="hljs-keyword">from</span> <span class="hljs-string">'../types/Message'</span>;

<span class="hljs-comment">// Custom hook to manage a collection of messages</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useMessages</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// State to hold an array of Message objects, starting empty</span>
  <span class="hljs-keyword">const</span> [messages, setMessages] = useState&lt;Message[]&gt;([]);

  <span class="hljs-comment">// Function to add a new message to the collection</span>
  <span class="hljs-keyword">const</span> addMessage = <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, sender: 'user' | 'bot'</span>) =&gt;</span> {
    <span class="hljs-comment">// Create a new message object with all required properties</span>
    <span class="hljs-keyword">const</span> newMessage: Message = {
      <span class="hljs-comment">// Generate unique ID using timestamp + random string for React keys</span>
      id: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)}</span>`</span>,
      text,     <span class="hljs-comment">// The message content</span>
      sender,   <span class="hljs-comment">// Who sent it: 'user' or 'bot'</span>
      timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()  <span class="hljs-comment">// When the message was created</span>
    };

    <span class="hljs-comment">// Update state by adding the new message to the end of the array</span>
    <span class="hljs-comment">// Using spread operator to create new array (immutable update)</span>
    setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, newMessage]);
  };

  <span class="hljs-comment">// Return the current state and functions for external components to use</span>
  <span class="hljs-keyword">return</span> {
    messages,     <span class="hljs-comment">// Current array of messages</span>
    addMessage    <span class="hljs-comment">// Function to add new messages</span>
  };
}
</div></code></pre>
<h2 id="component-testing-with-react-testing-library">Component Testing with React Testing Library</h2>
<p>Now let's test our React components using React Testing Library.</p>
<h3 id="%F0%9F%93%84-step-10-message-component">📄 Step 10: Message Component</h3>
<p><strong>Create:</strong> <code>src/components/__tests__/MessageComponent.test.tsx</code></p>
<p><strong>🔴 RED: Test the Message component</strong></p>
<p><strong>Create <code>src/components/__tests__/MessageComponent.test.tsx</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 📄 Step 10: Message Component Tests</span>
<span class="hljs-comment">// Import React Testing Library utilities for component testing</span>
<span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-comment">// Import the component we want to test</span>
<span class="hljs-keyword">import</span> { MessageComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'../MessageComponent'</span>;
<span class="hljs-comment">// Import the Message type for creating test data</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { Message } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../types/Message'</span>;

<span class="hljs-comment">// Test suite for the MessageComponent</span>
describe(<span class="hljs-string">'MessageComponent'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Mock data: Create a sample user message for testing</span>
  <span class="hljs-keyword">const</span> mockUserMessage: Message = {
    id: <span class="hljs-string">'test-1'</span>,                              <span class="hljs-comment">// Unique identifier</span>
    text: <span class="hljs-string">'Hello there!'</span>,                      <span class="hljs-comment">// Message content</span>
    sender: <span class="hljs-string">'user'</span>,                            <span class="hljs-comment">// Sender type</span>
    timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2024-01-01T12:00:00Z'</span>) <span class="hljs-comment">// Fixed timestamp for consistent testing</span>
  };

  <span class="hljs-comment">// Mock data: Create a sample bot message for testing</span>
  <span class="hljs-keyword">const</span> mockBotMessage: Message = {
    id: <span class="hljs-string">'test-2'</span>,                              <span class="hljs-comment">// Different ID from user message</span>
    text: <span class="hljs-string">'Hi! How can I help?'</span>,               <span class="hljs-comment">// Bot response content</span>
    sender: <span class="hljs-string">'bot'</span>,                             <span class="hljs-comment">// Bot sender type</span>
    timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2024-01-01T12:01:00Z'</span>) <span class="hljs-comment">// One minute later</span>
  };

  <span class="hljs-comment">// Test 1: Verify user messages render with correct content and styling</span>
  it(<span class="hljs-string">'should render user message with correct styling'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Render the component with user message data</span>
    render(&lt;MessageComponent message={mockUserMessage} /&gt;);
    
    <span class="hljs-comment">// Find the rendered message text in the DOM</span>
    <span class="hljs-keyword">const</span> messageElement = screen.getByText(<span class="hljs-string">'Hello there!'</span>);
    <span class="hljs-comment">// Assert the message appears in the document</span>
    expect(messageElement).toBeInTheDocument();
    <span class="hljs-comment">// Assert it has the correct CSS class for user styling</span>
    expect(messageElement).toHaveClass(<span class="hljs-string">'user-message'</span>);
  });

  <span class="hljs-comment">// Test 2: Verify bot messages render with correct content and different styling</span>
  it(<span class="hljs-string">'should render bot message with correct styling'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Render the component with bot message data</span>
    render(&lt;MessageComponent message={mockBotMessage} /&gt;);
    
    <span class="hljs-comment">// Find the bot's message text</span>
    <span class="hljs-keyword">const</span> messageElement = screen.getByText(<span class="hljs-string">'Hi! How can I help?'</span>);
    <span class="hljs-comment">// Assert the content is rendered</span>
    expect(messageElement).toBeInTheDocument();
    <span class="hljs-comment">// Assert it has different CSS class for bot styling</span>
    expect(messageElement).toHaveClass(<span class="hljs-string">'bot-message'</span>);
  });

  <span class="hljs-comment">// Test 3: Ensure component has proper accessibility attributes for screen readers</span>
  it(<span class="hljs-string">'should have proper accessibility attributes'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Render with user message</span>
    render(&lt;MessageComponent message={mockUserMessage} /&gt;);
    
    <span class="hljs-comment">// Find element by its semantic role (list item in a chat)</span>
    <span class="hljs-keyword">const</span> messageElement = screen.getByRole(<span class="hljs-string">'listitem'</span>);
    <span class="hljs-comment">// Verify it has descriptive aria-label for accessibility</span>
    expect(messageElement).toHaveAttribute(<span class="hljs-string">'aria-label'</span>, <span class="hljs-string">'Message from user'</span>);
  });
});
</div></code></pre>
<p><strong>🟢 GREEN: Implement the MessageComponent</strong></p>
<p><strong>Create <code>src/components/MessageComponent.tsx</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 📄 Step 10: MessageComponent Implementation (GREEN Phase)</span>
<span class="hljs-comment">// Import React for JSX and component definition</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-comment">// Import our Message type for prop validation</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { Message } <span class="hljs-keyword">from</span> <span class="hljs-string">'../types/Message'</span>;

<span class="hljs-comment">// Define the props interface for type safety</span>
<span class="hljs-keyword">interface</span> MessageComponentProps {
  message: Message;  <span class="hljs-comment">// The message object to display</span>
}

<span class="hljs-comment">// Functional component to render a single message</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MessageComponent</span>(<span class="hljs-params">{ message }: MessageComponentProps</span>): <span class="hljs-title">React</span>.<span class="hljs-title">JSX</span>.<span class="hljs-title">Element</span> </span>{
  <span class="hljs-keyword">return</span> (
    &lt;li 
      <span class="hljs-comment">// Dynamic CSS class based on sender: 'message user-message' or 'message bot-message'</span>
      className={<span class="hljs-string">`message <span class="hljs-subst">${message.sender}</span>-message`</span>}
      <span class="hljs-comment">// Semantic HTML role for screen readers</span>
      role=<span class="hljs-string">"listitem"</span>
      <span class="hljs-comment">// Descriptive aria-label for accessibility</span>
      aria-label={<span class="hljs-string">`Message from <span class="hljs-subst">${message.sender}</span>`</span>}
    &gt;
      {<span class="hljs-comment">/* Display the message text content */</span>}
      {message.text}
    &lt;<span class="hljs-regexp">/li&gt;
  );
}
</span></div></code></pre>
<h3 id="%E2%8C%A8%EF%B8%8F-step-11-chat-input-component">⌨️ Step 11: Chat Input Component</h3>
<p><strong>Create:</strong> <code>src/components/__tests__/ChatInput.test.tsx</code></p>
<p><strong>🔴 RED: Test the ChatInput component</strong></p>
<p><strong>Create <code>src/components/__tests__/ChatInput.test.tsx</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// ⌨️ Step 11: Chat Input Component Tests</span>
<span class="hljs-comment">// Import React Testing Library utilities for component testing</span>
<span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-comment">// Import userEvent for realistic user interactions (typing, clicking)</span>
<span class="hljs-keyword">import</span> userEvent <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/user-event'</span>;
<span class="hljs-comment">// Import the ChatInput component we want to test</span>
<span class="hljs-keyword">import</span> { ChatInput } <span class="hljs-keyword">from</span> <span class="hljs-string">'../ChatInput'</span>;

<span class="hljs-comment">// Test suite for ChatInput component - covers user input and message sending</span>
describe(<span class="hljs-string">'ChatInput'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Test 1: Basic rendering - verify UI elements are present</span>
  it(<span class="hljs-string">'should render input and send button'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Create a mock function to track if onSend is called</span>
    <span class="hljs-keyword">const</span> mockOnSend = jest.fn();
    <span class="hljs-comment">// Render the component with the mock prop</span>
    render(&lt;ChatInput onSend={mockOnSend} /&gt;);
    
    <span class="hljs-comment">// Assert that the input field exists with correct placeholder</span>
    expect(screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>)).toBeInTheDocument();
    <span class="hljs-comment">// Assert that the send button exists and is accessible by screen readers</span>
    expect(screen.getByRole(<span class="hljs-string">'button'</span>, { name: <span class="hljs-regexp">/send/i</span> })).toBeInTheDocument();
  });

  <span class="hljs-comment">// Test 2: Button click interaction - verify messages are sent when button is clicked</span>
  it(<span class="hljs-string">'should call onSend when button is clicked'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// Set up userEvent for realistic user interactions</span>
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    <span class="hljs-comment">// Create mock function to verify callback is called correctly</span>
    <span class="hljs-keyword">const</span> mockOnSend = jest.fn();
    render(&lt;ChatInput onSend={mockOnSend} /&gt;);
    
    <span class="hljs-comment">// Find the input field and send button elements</span>
    <span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>);
    <span class="hljs-keyword">const</span> sendButton = screen.getByRole(<span class="hljs-string">'button'</span>, { name: <span class="hljs-regexp">/send/i</span> });
    
    <span class="hljs-comment">// Simulate user typing a message</span>
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'Hello world'</span>);
    <span class="hljs-comment">// Simulate user clicking the send button</span>
    <span class="hljs-keyword">await</span> user.click(sendButton);
    
    <span class="hljs-comment">// Verify that onSend was called with the correct message text</span>
    expect(mockOnSend).toHaveBeenCalledWith(<span class="hljs-string">'Hello world'</span>);
  });

  <span class="hljs-comment">// Test 3: Keyboard interaction - verify Enter key sends messages (common UX pattern)</span>
  it(<span class="hljs-string">'should call onSend when Enter is pressed'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    <span class="hljs-keyword">const</span> mockOnSend = jest.fn();
    render(&lt;ChatInput onSend={mockOnSend} /&gt;);
    
    <span class="hljs-comment">// Find the input field</span>
    <span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>);
    
    <span class="hljs-comment">// Type a message</span>
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'Hello world'</span>);
    <span class="hljs-comment">// Simulate pressing Enter key (common chat interface behavior)</span>
    <span class="hljs-keyword">await</span> user.keyboard(<span class="hljs-string">'{Enter}'</span>);
    
    <span class="hljs-comment">// Verify the message was sent via keyboard shortcut</span>
    expect(mockOnSend).toHaveBeenCalledWith(<span class="hljs-string">'Hello world'</span>);
  });

  <span class="hljs-comment">// Test 4: Input clearing behavior - ensure input resets after sending</span>
  it(<span class="hljs-string">'should clear input after sending'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    <span class="hljs-keyword">const</span> mockOnSend = jest.fn();
    render(&lt;ChatInput onSend={mockOnSend} /&gt;);
    
    <span class="hljs-comment">// Type assert to HTMLInputElement to access .value property</span>
    <span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>) <span class="hljs-keyword">as</span> HTMLInputElement;
    
    <span class="hljs-comment">// Type and send a message</span>
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'Hello world'</span>);
    <span class="hljs-keyword">await</span> user.keyboard(<span class="hljs-string">'{Enter}'</span>);
    
    <span class="hljs-comment">// Verify input field is cleared after sending (good UX)</span>
    expect(input.value).toBe(<span class="hljs-string">''</span>);
  });

  <span class="hljs-comment">// Test 5: Empty message prevention - avoid sending blank messages</span>
  it(<span class="hljs-string">'should not send empty messages'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    <span class="hljs-keyword">const</span> mockOnSend = jest.fn();
    render(&lt;ChatInput onSend={mockOnSend} /&gt;);
    
    <span class="hljs-comment">// Try to send without typing anything</span>
    <span class="hljs-keyword">const</span> sendButton = screen.getByRole(<span class="hljs-string">'button'</span>, { name: <span class="hljs-regexp">/send/i</span> });
    <span class="hljs-keyword">await</span> user.click(sendButton);
    
    <span class="hljs-comment">// Verify onSend was NOT called (prevents spam/empty messages)</span>
    expect(mockOnSend).not.toHaveBeenCalled();
  });

  <span class="hljs-comment">// Test 6: Button state management - disable send button when input is empty</span>
  it(<span class="hljs-string">'should disable send button when input is empty'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> mockOnSend = jest.fn();
    render(&lt;ChatInput onSend={mockOnSend} /&gt;);
    
    <span class="hljs-comment">// Check initial state - button should be disabled when no text</span>
    <span class="hljs-keyword">const</span> sendButton = screen.getByRole(<span class="hljs-string">'button'</span>, { name: <span class="hljs-regexp">/send/i</span> });
    expect(sendButton).toBeDisabled();
    
    <span class="hljs-comment">// This provides visual feedback to users about when they can send</span>
  });
});
</div></code></pre>
<p><strong>🤔 Understanding ChatInput Test Patterns - Deep Dive</strong></p>
<p>The ChatInput tests demonstrate several important testing concepts that are crucial for building robust React applications:</p>
<p><strong>1. Mock Functions (<code>jest.fn()</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> mockOnSend = jest.fn();
<span class="hljs-comment">// Creates a "spy" function that:</span>
<span class="hljs-comment">// - Tracks if it was called</span>
<span class="hljs-comment">// - Records what arguments it received</span>
<span class="hljs-comment">// - Allows us to verify component behavior</span>
</div></code></pre>
<p><strong>Why use mocks?</strong> In unit testing, we want to test the ChatInput component in isolation. We don't care about what the actual <code>onSend</code> function does - we just want to verify that ChatInput calls it correctly.</p>
<p><strong>2. User Interaction Testing:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> user = userEvent.setup();
<span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'Hello world'</span>);
<span class="hljs-keyword">await</span> user.click(sendButton);
</div></code></pre>
<p><strong>Why <code>userEvent</code> instead of <code>fireEvent</code>?</strong></p>
<ul>
<li><code>fireEvent</code> triggers events directly (artificial)</li>
<li><code>userEvent</code> simulates actual user behavior (realistic)</li>
<li><code>userEvent</code> includes focus changes, key sequences, and timing that real users experience</li>
</ul>
<p><strong>3. Accessibility-First Testing:</strong></p>
<pre class="hljs"><code><div>screen.getByRole(<span class="hljs-string">'button'</span>, { name: <span class="hljs-regexp">/send/i</span> })
screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>)
</div></code></pre>
<p><strong>Why query by role/label instead of class/id?</strong> This approach:</p>
<ul>
<li>Tests how screen readers and assistive technology interact with your component</li>
<li>Ensures your component is accessible to all users</li>
<li>Makes tests more resilient to CSS changes</li>
</ul>
<p><strong>4. Edge Case Testing:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Test empty input handling</span>
expect(mockOnSend).not.toHaveBeenCalled();

<span class="hljs-comment">// Test button disabled state</span>
expect(sendButton).toBeDisabled();
</div></code></pre>
<p><strong>Why test edge cases?</strong> Real users will:</p>
<ul>
<li>Try to send empty messages</li>
<li>Click disabled buttons</li>
<li>Use keyboard shortcuts</li>
<li>Expect visual feedback</li>
</ul>
<p><strong>5. State Verification:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>) <span class="hljs-keyword">as</span> HTMLInputElement;
expect(input.value).toBe(<span class="hljs-string">''</span>);
</div></code></pre>
<p><strong>Why check input clearing?</strong> Good UX means:</p>
<ul>
<li>Users don't have to manually clear the input</li>
<li>No accidental duplicate messages</li>
<li>Clear visual feedback that message was sent</li>
</ul>
<p><strong>🎯 Testing Philosophy: &quot;Test Behavior, Not Implementation&quot;</strong></p>
<p>Notice our tests focus on:</p>
<ul>
<li>✅ &quot;When user types and clicks send, does onSend get called?&quot;</li>
<li>✅ &quot;When user presses Enter, does it send the message?&quot;</li>
<li>✅ &quot;Does the input clear after sending?&quot;</li>
</ul>
<p>Not on:</p>
<ul>
<li>❌ &quot;Does the component use useState internally?&quot;</li>
<li>❌ &quot;Does handleSend function exist?&quot;</li>
<li>❌ &quot;What's the exact CSS class structure?&quot;</li>
</ul>
<p>This makes tests more valuable and less brittle!</p>
<p><strong>🟢 GREEN: Implement the ChatInput component</strong></p>
<p><strong>Create <code>src/components/ChatInput.tsx</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// ⌨️ Step 11: ChatInput Component Implementation (GREEN Phase)</span>
<span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">interface</span> ChatInputProps {
  onSend: <span class="hljs-function">(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChatInput</span>(<span class="hljs-params">{ onSend }: ChatInputProps</span>): <span class="hljs-title">React</span>.<span class="hljs-title">JSX</span>.<span class="hljs-title">Element</span> </span>{
  <span class="hljs-keyword">const</span> [input, setInput] = useState(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> handleSend = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (input.trim() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span>;
    
    onSend(input.trim());
    setInput(<span class="hljs-string">''</span>);
  };

  <span class="hljs-keyword">const</span> handleKeyPress = <span class="hljs-function">(<span class="hljs-params">event: React.KeyboardEvent&lt;HTMLInputElement&gt;</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (event.key === <span class="hljs-string">'Enter'</span> &amp;&amp; !event.shiftKey) {
      event.preventDefault();
      handleSend();
    }
  };

  <span class="hljs-keyword">return</span> (
    &lt;div className=<span class="hljs-string">"input-container"</span>&gt;
      &lt;input
        <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span>
        value={input}
        onChange={<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> setInput(e.target.value)}
        onKeyPress={handleKeyPress}
        placeholder=<span class="hljs-string">"Type your message..."</span>
        className=<span class="hljs-string">"user-input"</span>
      /&gt;
      &lt;button
        onClick={handleSend}
        disabled={input.trim() === <span class="hljs-string">''</span>}
        className=<span class="hljs-string">"send-button"</span>
      &gt;
        Send
      &lt;<span class="hljs-regexp">/button&gt;
    &lt;/</span>div&gt;
  );
}
</div></code></pre>
<h3 id="%F0%9F%92%AC-step-12-main-chat-component">💬 Step 12: Main Chat Component</h3>
<p><strong>Create:</strong> <code>src/components/__tests__/Chat.test.tsx</code></p>
<p><strong>🔴 RED: Test the main Chat component</strong></p>
<p><strong>Create <code>src/components/__tests__/Chat.test.tsx</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 💬 Step 12: Main Chat Component Tests</span>
<span class="hljs-keyword">import</span> { render, screen, waitFor } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> userEvent <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/user-event'</span>;
<span class="hljs-keyword">import</span> { Chat } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Chat'</span>;

<span class="hljs-comment">// Mock the bot service</span>
jest.mock(<span class="hljs-string">'../../services/botService'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
  getBotResponse: jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    text: <span class="hljs-string">'Mocked bot response'</span>,
    delay: <span class="hljs-number">100</span>
  }))
}));

<span class="hljs-comment">// Global mock for scrollIntoView</span>
beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  Element.prototype.scrollIntoView = jest.fn();
});

describe(<span class="hljs-string">'Chat'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  it(<span class="hljs-string">'should render welcome message only once'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    render(&lt;Chat /&gt;);
    
    <span class="hljs-keyword">const</span> welcomeMessages = screen.getAllByText(<span class="hljs-regexp">/welcome.*TDD/i</span>);
    expect(welcomeMessages).toHaveLength(<span class="hljs-number">1</span>);
  });

  it(<span class="hljs-string">'should render chat container'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    render(&lt;Chat /&gt;);
    
    expect(screen.getByRole(<span class="hljs-string">'main'</span>)).toHaveClass(<span class="hljs-string">'chat-container'</span>);
  });

  it(<span class="hljs-string">'should add user message when sent'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    render(&lt;Chat /&gt;);
    
    <span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>);
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'Hello'</span>);
    <span class="hljs-keyword">await</span> user.keyboard(<span class="hljs-string">'{Enter}'</span>);
    
    expect(screen.getByText(<span class="hljs-string">'Hello'</span>)).toBeInTheDocument();
  });

  it(<span class="hljs-string">'should add bot response after user message'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    render(&lt;Chat /&gt;);
    
    <span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>);
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'Hello'</span>);
    <span class="hljs-keyword">await</span> user.keyboard(<span class="hljs-string">'{Enter}'</span>);
    
    <span class="hljs-keyword">await</span> waitFor(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      expect(screen.getByText(<span class="hljs-string">'Mocked bot response'</span>)).toBeInTheDocument();
    });
  });

  it(<span class="hljs-string">'should scroll to bottom when new message is added'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    render(&lt;Chat /&gt;);
    
    <span class="hljs-comment">// Clear any previous calls from component mount</span>
    jest.clearAllMocks();
    
    <span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>);
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'Hello'</span>);
    <span class="hljs-keyword">await</span> user.keyboard(<span class="hljs-string">'{Enter}'</span>);
    
    expect(Element.prototype.scrollIntoView).toHaveBeenCalled();
  });
});
</div></code></pre>
<p><strong>� Common Issue: scrollIntoView Error</strong></p>
<p>If you encounter errors like:</p>
<pre class="hljs"><code><div>TypeError: messagesEndRef.current?.scrollIntoView is not a function
</div></code></pre>
<p><strong>🤔 Why This Happens:</strong></p>
<p>The <code>scrollIntoView</code> method is a browser DOM API that doesn't exist in the jsdom testing environment. When your Chat component tries to scroll to the bottom on mount (via <code>useEffect</code>), the test fails because <code>scrollIntoView</code> is undefined.</p>
<p><strong>🔧 Solution: Global Mock Setup</strong></p>
<p>Add this <strong>before</strong> your describe block to mock <code>scrollIntoView</code> for all tests:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Import React Testing Library utilities for component testing</span>
<span class="hljs-keyword">import</span> { render, screen, waitFor } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> userEvent <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/user-event'</span>;
<span class="hljs-keyword">import</span> { Chat } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Chat'</span>;

<span class="hljs-comment">// Mock the bot service</span>
jest.mock(<span class="hljs-string">'../../services/botService'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
  getBotResponse: jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    text: <span class="hljs-string">'Mocked bot response'</span>,
    delay: <span class="hljs-number">100</span>
  }))
}));

<span class="hljs-comment">// Global mock for scrollIntoView - jsdom doesn't implement this browser API</span>
<span class="hljs-comment">// We need this mock for ALL tests since the Chat component calls scrollToBottom on mount</span>
beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  Element.prototype.scrollIntoView = jest.fn();
});

describe(<span class="hljs-string">'Chat'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// ... rest of your tests</span>
});
</div></code></pre>
<p><strong>🎯 Why This Works:</strong></p>
<ol>
<li><strong>Global Setup</strong>: <code>beforeAll()</code> runs once before any tests in this file</li>
<li><strong>Prototype Mocking</strong>: We mock the method on <code>Element.prototype</code> so all DOM elements have it</li>
<li><strong>Covers All Tests</strong>: Since Chat component scrolls on mount, every test that renders Chat needs this mock</li>
</ol>
<p><strong>🔍 Alternative: Individual Test Mocking</strong></p>
<p>If you only want to mock for specific tests:</p>
<pre class="hljs"><code><div>it(<span class="hljs-string">'should scroll to bottom when new message is added'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> user = userEvent.setup();
  render(&lt;Chat /&gt;);
  
  <span class="hljs-comment">// Clear any previous calls from component mount</span>
  jest.clearAllMocks();
  
  <span class="hljs-comment">// Your test code here...</span>
  
  expect(Element.prototype.scrollIntoView).toHaveBeenCalled();
});
</div></code></pre>
<p><strong>💡 Key Lesson:</strong></p>
<p>When testing components that use browser APIs (like <code>scrollIntoView</code>, <code>localStorage</code>, <code>fetch</code>), you need to mock them because the testing environment (jsdom) doesn't implement all browser features.</p>
<p><strong>�🟢 GREEN: Implement the Chat component</strong></p>
<p><strong>Create <code>src/components/Chat.tsx</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 💬 Step 12: Chat Component Implementation (FIXED)</span>
<span class="hljs-keyword">import</span> React, { useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useMessages } <span class="hljs-keyword">from</span> <span class="hljs-string">'../hooks/useMessages'</span>;
<span class="hljs-keyword">import</span> { getBotResponse } <span class="hljs-keyword">from</span> <span class="hljs-string">'../services/botService'</span>;
<span class="hljs-keyword">import</span> { MessageComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./MessageComponent'</span>;
<span class="hljs-keyword">import</span> { ChatInput } <span class="hljs-keyword">from</span> <span class="hljs-string">'./ChatInput'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Chat</span>(<span class="hljs-params"></span>): <span class="hljs-title">React</span>.<span class="hljs-title">JSX</span>.<span class="hljs-title">Element</span> </span>{
  <span class="hljs-keyword">const</span> { messages, addMessage } = useMessages();
  <span class="hljs-keyword">const</span> messagesEndRef = useRef&lt;HTMLDivElement&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> isInitialized = useRef(<span class="hljs-literal">false</span>); <span class="hljs-comment">// ✅ Track if welcome message was added</span>

  <span class="hljs-keyword">const</span> scrollToBottom = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    messagesEndRef.current?.scrollIntoView({ behavior: <span class="hljs-string">'smooth'</span> });
  };

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    scrollToBottom();
  }, [messages]);

  <span class="hljs-comment">// ✅ FIXED: Use useRef to prevent duplicate welcome messages in StrictMode</span>
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!isInitialized.current) {
      addMessage(
        <span class="hljs-string">"Welcome! I'm a chatbot built with TDD. Try typing 'hello', 'vite', or 'react'!"</span>,
        <span class="hljs-string">'bot'</span>
      );
      isInitialized.current = <span class="hljs-literal">true</span>;
    }
  }, [addMessage]);

  <span class="hljs-keyword">const</span> handleSendMessage = <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
    <span class="hljs-comment">// Add user message immediately</span>
    addMessage(text, <span class="hljs-string">'user'</span>);

    <span class="hljs-comment">// Get bot response and add it after delay</span>
    <span class="hljs-keyword">const</span> botResponse = getBotResponse(text);
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      addMessage(botResponse.text, <span class="hljs-string">'bot'</span>);
    }, botResponse.delay);
  };

  <span class="hljs-keyword">return</span> (
    &lt;main className=<span class="hljs-string">"chat-container"</span> role=<span class="hljs-string">"main"</span>&gt;
      &lt;div className=<span class="hljs-string">"chat-messages"</span>&gt;
        &lt;ul role=<span class="hljs-string">"log"</span> aria-label=<span class="hljs-string">"Chat messages"</span>&gt;
          {messages.map(<span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> (
            &lt;MessageComponent key={message.id} message={message} /&gt;
          ))}
        &lt;<span class="hljs-regexp">/ul&gt;
        &lt;div ref={messagesEndRef} /</span>&gt;
      &lt;<span class="hljs-regexp">/div&gt;
      
      &lt;ChatInput onSend={handleSendMessage} /</span>&gt;
    &lt;<span class="hljs-regexp">/main&gt;
  );
}
</span></div></code></pre>
<h2 id="%F0%9F%94%A7-understanding-the-strictmode-fix">🔧 Understanding the StrictMode Fix</h2>
<p><strong>🚨 Common Issue: Duplicate Welcome Messages</strong></p>
<p>If you see <strong>two welcome messages</strong> when you run your app, this is due to <strong>React StrictMode</strong> in development. Here's why and how we fixed it:</p>
<h3 id="%E2%9D%8C-the-problem"><strong>❌ The Problem:</strong></h3>
<pre class="hljs"><code><div><span class="hljs-comment">// This approach can cause duplicates in StrictMode</span>
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (messages.length === <span class="hljs-number">0</span>) {
    addMessage(<span class="hljs-string">"Welcome message"</span>, <span class="hljs-string">'bot'</span>);
  }
}, [addMessage, messages.length]);
</div></code></pre>
<p><strong>Why it happens:</strong></p>
<ul>
<li><strong>🔄 React StrictMode</strong>: Intentionally runs effects twice in development</li>
<li><strong>⚡ Race Condition</strong>: Effect runs before messages state updates</li>
<li><strong>📱 Production vs Development</strong>: Only happens in development mode</li>
</ul>
<h3 id="%E2%9C%85-the-solution-useref-tracking"><strong>✅ The Solution: useRef Tracking</strong></h3>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> isInitialized = useRef(<span class="hljs-literal">false</span>);

useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (!isInitialized.current) {
    addMessage(<span class="hljs-string">"Welcome message"</span>, <span class="hljs-string">'bot'</span>);
    isInitialized.current = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ← Prevents duplicate execution</span>
  }
}, [addMessage]);
</div></code></pre>
<p><strong>Why this works:</strong></p>
<ul>
<li><strong>🎯 Persistent Reference</strong>: <code>useRef</code> value persists across re-renders</li>
<li><strong>🚫 Duplicate Prevention</strong>: Only runs once, even in StrictMode</li>
<li><strong>⚡ Immediate Effect</strong>: Flag is set before any re-renders can occur</li>
</ul>
<p><strong>💡 Key Learning:</strong> This is a perfect example of why TDD is valuable - your tests should catch this duplicate message issue, ensuring your app works correctly in both development and production!</p>
<h3 id="%F0%9F%8E%AF-step-13-app-component-integration">🎯 Step 13: App Component Integration</h3>
<p><strong>Create:</strong> <code>src/__tests__/App.test.tsx</code></p>
<p><strong>🔴 RED: Test the complete App</strong></p>
<p><strong>Create <code>src/__tests__/App.test.tsx</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🚀 Step 13: App Component Integration Tests</span>
<span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> userEvent <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/user-event'</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'../App'</span>;

describe(<span class="hljs-string">'App'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  it(<span class="hljs-string">'should render the chat application'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    render(&lt;App /&gt;);
    
    expect(screen.getByRole(<span class="hljs-string">'main'</span>)).toBeInTheDocument();
    expect(screen.getByText(<span class="hljs-regexp">/welcome/i</span>)).toBeInTheDocument();
  });

  it(<span class="hljs-string">'should handle complete chat flow'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    render(&lt;App /&gt;);
    
    <span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>);
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'hello'</span>);
    <span class="hljs-keyword">await</span> user.keyboard(<span class="hljs-string">'{Enter}'</span>);
    
    <span class="hljs-comment">// Check user message appears</span>
    expect(screen.getByText(<span class="hljs-string">'hello'</span>)).toBeInTheDocument();
    
    <span class="hljs-comment">// Check bot response appears (with original bot service, not mocked)</span>
    <span class="hljs-keyword">await</span> screen.findByText(<span class="hljs-regexp">/Hello.*TDD.*chatbot/i</span>, {}, { timeout: <span class="hljs-number">2000</span> });
  });
});
</div></code></pre>
<p><strong>🟢 GREEN: Implement the App component</strong></p>
<p><strong>Create/Replace <code>src/App.tsx</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🚀 Step 13: App Component Implementation (GREEN Phase)</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { Chat } <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/Chat'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./App.css'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>): <span class="hljs-title">React</span>.<span class="hljs-title">JSX</span>.<span class="hljs-title">Element</span> </span>{
  <span class="hljs-keyword">return</span> (
    &lt;div className=<span class="hljs-string">"App"</span>&gt;
      &lt;Chat /&gt;
    &lt;<span class="hljs-regexp">/div&gt;
  );
}

export default App;
</span></div></code></pre>
<p><strong>Add CSS (Create/Replace <code>src/App.css</code>):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">/* App.css - TDD Chatbot Styles */</span>
* {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">box-sizing</span>: border-box;
}

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">font-family</span>: Arial, sans-serif;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">justify-content</span>: center;
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
}

<span class="hljs-selector-class">.App</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">justify-content</span>: center;
  <span class="hljs-attribute">align-items</span>: center;
}

<span class="hljs-selector-class">.chat-container</span> {
  <span class="hljs-attribute">background-color</span>: white;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>);
  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">flex-direction</span>: column;
}

<span class="hljs-selector-class">.chat-messages</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">overflow-y</span>: auto;
  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>;
}

<span class="hljs-selector-class">.chat-messages</span> <span class="hljs-selector-tag">ul</span> {
  <span class="hljs-attribute">list-style</span>: none;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
}

<span class="hljs-selector-class">.message</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span> <span class="hljs-number">0</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">12px</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">80%</span>;
  <span class="hljs-attribute">display</span>: block;
}

<span class="hljs-selector-class">.user-message</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#007bff</span>;
  <span class="hljs-attribute">color</span>: white;
  <span class="hljs-attribute">margin-left</span>: auto;
  <span class="hljs-attribute">text-align</span>: right;
}

<span class="hljs-selector-class">.bot-message</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#e0e0e0</span>;
  <span class="hljs-attribute">color</span>: black;
  <span class="hljs-attribute">margin-right</span>: auto;
}

<span class="hljs-selector-class">.input-container</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
}

<span class="hljs-selector-class">.user-input</span> {
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;
}

<span class="hljs-selector-class">.send-button</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">16px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#007bff</span>;
  <span class="hljs-attribute">color</span>: white;
  <span class="hljs-attribute">border</span>: none;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">cursor</span>: pointer;
}

<span class="hljs-selector-class">.send-button</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">:not(</span><span class="hljs-selector-pseudo">:disabled)</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0056b3</span>;
}

<span class="hljs-selector-class">.send-button</span><span class="hljs-selector-pseudo">:disabled</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#6c757d</span>;
  <span class="hljs-attribute">cursor</span>: not-allowed;
}
</div></code></pre>
<h2 id="%F0%9F%A7%AA-step-14-integration-testing">🧪 Step 14: Integration Testing</h2>
<p>Now let's test how our components work together.</p>
<p><strong>Create <code>src/__tests__/integration/ChatFlow.test.tsx</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { render, screen, waitFor } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> userEvent <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/user-event'</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'../../App'</span>;

describe(<span class="hljs-string">'Chat Integration'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  it(<span class="hljs-string">'should handle complete conversation flow'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    render(&lt;App /&gt;);

    <span class="hljs-comment">// Check initial welcome message</span>
    expect(screen.getByText(<span class="hljs-regexp">/welcome.*TDD/i</span>)).toBeInTheDocument();

    <span class="hljs-comment">// Send hello message</span>
    <span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>);
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'hello'</span>);
    <span class="hljs-keyword">await</span> user.keyboard(<span class="hljs-string">'{Enter}'</span>);

    <span class="hljs-comment">// Verify user message appears</span>
    expect(screen.getByText(<span class="hljs-string">'hello'</span>)).toBeInTheDocument();

    <span class="hljs-comment">// Wait for bot response</span>
    <span class="hljs-keyword">await</span> waitFor(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      expect(screen.getByText(<span class="hljs-regexp">/Hello.*TDD.*chatbot/i</span>)).toBeInTheDocument();
    }, { timeout: <span class="hljs-number">2000</span> });

    <span class="hljs-comment">// Send vite message</span>
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'vite'</span>);
    <span class="hljs-keyword">await</span> user.keyboard(<span class="hljs-string">'{Enter}'</span>);

    <span class="hljs-comment">// Verify vite response</span>
    <span class="hljs-keyword">await</span> waitFor(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      expect(screen.getByText(<span class="hljs-regexp">/Vite.*amazing.*TDD/i</span>)).toBeInTheDocument();
    }, { timeout: <span class="hljs-number">2000</span> });

    <span class="hljs-comment">// Check that we have multiple messages</span>
    <span class="hljs-keyword">const</span> messages = screen.getAllByRole(<span class="hljs-string">'listitem'</span>);
    expect(messages.length).toBeGreaterThan(<span class="hljs-number">3</span>); <span class="hljs-comment">// Welcome + hello + response + vite + response</span>
  });

  it(<span class="hljs-string">'should handle empty input properly'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    render(&lt;App /&gt;);

    <span class="hljs-keyword">const</span> sendButton = screen.getByRole(<span class="hljs-string">'button'</span>, { name: <span class="hljs-regexp">/send/i</span> });
    
    <span class="hljs-comment">// Button should be disabled initially</span>
    expect(sendButton).toBeDisabled();

    <span class="hljs-comment">// Clicking disabled button should not add message</span>
    <span class="hljs-keyword">await</span> user.click(sendButton);
    
    <span class="hljs-comment">// Should only have welcome message</span>
    <span class="hljs-keyword">const</span> messages = screen.getAllByRole(<span class="hljs-string">'listitem'</span>);
    expect(messages).toHaveLength(<span class="hljs-number">1</span>);
  });

  it(<span class="hljs-string">'should maintain message order'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> user = userEvent.setup();
    render(&lt;App /&gt;);

    <span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>);

    <span class="hljs-comment">// Send first message</span>
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'First message'</span>);
    <span class="hljs-keyword">await</span> user.keyboard(<span class="hljs-string">'{Enter}'</span>);

    <span class="hljs-comment">// Wait for bot response</span>
    <span class="hljs-keyword">await</span> waitFor(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      expect(screen.getByText(<span class="hljs-regexp">/First message.*TDD/i</span>)).toBeInTheDocument();
    });

    <span class="hljs-comment">// Send second message</span>
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'Second message'</span>);
    <span class="hljs-keyword">await</span> user.keyboard(<span class="hljs-string">'{Enter}'</span>);

    <span class="hljs-comment">// Check message order</span>
    <span class="hljs-keyword">const</span> messages = screen.getAllByRole(<span class="hljs-string">'listitem'</span>);
    <span class="hljs-keyword">const</span> messageTexts = messages.map(<span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> msg.textContent);
    
    expect(messageTexts).toContain(<span class="hljs-string">'First message'</span>);
    expect(messageTexts).toContain(<span class="hljs-string">'Second message'</span>);
    <span class="hljs-comment">// Welcome message should be first</span>
    expect(messageTexts[<span class="hljs-number">0</span>]).toMatch(<span class="hljs-regexp">/welcome.*TDD/i</span>);
  });
});
</div></code></pre>
<h2 id="%F0%9F%8C%90-step-15-end-to-end-testing-with-cypress">🌐 Step 15: End-to-End Testing with Cypress</h2>
<p><strong>Create <code>cypress.config.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'cypress'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig({
  e2e: {
    baseUrl: <span class="hljs-string">'http://localhost:5173'</span>,
    setupNodeEvents(on, config) {
      <span class="hljs-comment">// implement node event listeners here</span>
    },
  },
})
</div></code></pre>
<p><strong>Create <code>cypress/e2e/chatbot.cy.ts</code>:</strong></p>
<pre class="hljs"><code><div>describe(<span class="hljs-string">'Chatbot E2E Tests'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    cy.visit(<span class="hljs-string">'/'</span>);
  });

  it(<span class="hljs-string">'should load the chatbot application'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    cy.get(<span class="hljs-string">'[role="main"]'</span>).should(<span class="hljs-string">'be.visible'</span>);
    cy.contains(<span class="hljs-regexp">/welcome.*TDD/i</span>).should(<span class="hljs-string">'be.visible'</span>);
  });

  it(<span class="hljs-string">'should handle user interaction flow'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Type and send a message</span>
    cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>)
      .type(<span class="hljs-string">'hello'</span>);
    
    cy.get(<span class="hljs-string">'button'</span>).contains(<span class="hljs-string">'Send'</span>).click();

    <span class="hljs-comment">// Verify user message appears</span>
    cy.contains(<span class="hljs-string">'hello'</span>).should(<span class="hljs-string">'be.visible'</span>);

    <span class="hljs-comment">// Wait for and verify bot response</span>
    cy.contains(<span class="hljs-regexp">/Hello.*TDD.*chatbot/i</span>, { timeout: <span class="hljs-number">2000</span> })
      .should(<span class="hljs-string">'be.visible'</span>);
  });

  it(<span class="hljs-string">'should handle Enter key submission'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>)
      .type(<span class="hljs-string">'vite{enter}'</span>);

    cy.contains(<span class="hljs-string">'vite'</span>).should(<span class="hljs-string">'be.visible'</span>);
    cy.contains(<span class="hljs-regexp">/Vite.*amazing.*TDD/i</span>, { timeout: <span class="hljs-number">2000</span> })
      .should(<span class="hljs-string">'be.visible'</span>);
  });

  it(<span class="hljs-string">'should disable send button for empty input'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    cy.get(<span class="hljs-string">'button'</span>).contains(<span class="hljs-string">'Send'</span>)
      .should(<span class="hljs-string">'be.disabled'</span>);

    cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>)
      .type(<span class="hljs-string">'hello'</span>);

    cy.get(<span class="hljs-string">'button'</span>).contains(<span class="hljs-string">'Send'</span>)
      .should(<span class="hljs-string">'not.be.disabled'</span>);

    cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>)
      .clear();

    cy.get(<span class="hljs-string">'button'</span>).contains(<span class="hljs-string">'Send'</span>)
      .should(<span class="hljs-string">'be.disabled'</span>);
  });

  it(<span class="hljs-string">'should maintain conversation history'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Send multiple messages</span>
    cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>)
      .type(<span class="hljs-string">'hello{enter}'</span>);

    cy.contains(<span class="hljs-regexp">/Hello.*TDD.*chatbot/i</span>, { timeout: <span class="hljs-number">2000</span> });

    cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>)
      .type(<span class="hljs-string">'vite{enter}'</span>);

    cy.contains(<span class="hljs-regexp">/Vite.*amazing.*TDD/i</span>, { timeout: <span class="hljs-number">2000</span> });

    <span class="hljs-comment">// Check that all messages are still visible</span>
    cy.contains(<span class="hljs-string">'hello'</span>).should(<span class="hljs-string">'be.visible'</span>);
    cy.contains(<span class="hljs-string">'vite'</span>).should(<span class="hljs-string">'be.visible'</span>);
    cy.contains(<span class="hljs-regexp">/Hello.*TDD.*chatbot/i</span>).should(<span class="hljs-string">'be.visible'</span>);
    cy.contains(<span class="hljs-regexp">/Vite.*amazing.*TDD/i</span>).should(<span class="hljs-string">'be.visible'</span>);
  });

  it(<span class="hljs-string">'should have proper accessibility attributes'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    cy.get(<span class="hljs-string">'[role="main"]'</span>).should(<span class="hljs-string">'exist'</span>);
    cy.get(<span class="hljs-string">'[role="log"]'</span>).should(<span class="hljs-string">'exist'</span>);
    cy.get(<span class="hljs-string">'input'</span>).should(<span class="hljs-string">'have.attr'</span>, <span class="hljs-string">'placeholder'</span>);
    
    <span class="hljs-comment">// Send a message to create list items</span>
    cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>)
      .type(<span class="hljs-string">'hello{enter}'</span>);

    cy.get(<span class="hljs-string">'[role="listitem"]'</span>).should(<span class="hljs-string">'exist'</span>);
  });
});
</div></code></pre>
<h3 id="%F0%9F%9B%A0%EF%B8%8F-cypress-setup-and-support-files">🛠️ Cypress Setup and Support Files</h3>
<p><strong>Create Cypress support directory and files:</strong></p>
<p><strong>Create <code>cypress/support/e2e.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// ***********************************************************</span>
<span class="hljs-comment">// This example support/e2e.ts is processed and</span>
<span class="hljs-comment">// loaded automatically before your test files.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// This is a great place to put global configuration and</span>
<span class="hljs-comment">// behavior that modifies Cypress.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// You can change the location of this file or turn off</span>
<span class="hljs-comment">// automatically serving support files with the</span>
<span class="hljs-comment">// 'supportFile' configuration option.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// You can read more here:</span>
<span class="hljs-comment">// https://on.cypress.io/configuration</span>
<span class="hljs-comment">// ***********************************************************</span>

<span class="hljs-comment">// Import commands.ts using ES2015 syntax:</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./commands'</span>
</div></code></pre>
<p><strong>Create <code>cypress/support/commands.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">/// &lt;reference types="cypress" /&gt;</span>
<span class="hljs-comment">// ***********************************************</span>
<span class="hljs-comment">// This example commands.ts shows you how to</span>
<span class="hljs-comment">// create various custom commands and overwrite</span>
<span class="hljs-comment">// existing commands.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// For more comprehensive examples of custom</span>
<span class="hljs-comment">// commands please read more here:</span>
<span class="hljs-comment">// https://on.cypress.io/custom-commands</span>
<span class="hljs-comment">// ***********************************************</span>

<span class="hljs-keyword">declare</span> global {
  <span class="hljs-keyword">namespace</span> Cypress {
    <span class="hljs-keyword">interface</span> Chainable {
      <span class="hljs-comment">// Add custom command type definitions here</span>
      <span class="hljs-comment">// Example: login(email: string, password: string): Chainable&lt;void&gt;</span>
    }
  }
}

<span class="hljs-keyword">export</span> {};
</div></code></pre>
<h2 id="%F0%9F%93%9A-understanding-cypress-files-structure">📚 Understanding Cypress Files Structure</h2>
<h3 id="%F0%9F%94%A7-file-by-file-breakdown">🔧 File-by-File Breakdown</h3>
<h4 id="1-cypressconfigts---main-cypress-configuration">1. <strong><code>cypress.config.ts</code></strong> - Main Cypress Configuration</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'cypress'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig({
  e2e: {
    baseUrl: <span class="hljs-string">'http://localhost:5173'</span>,  <span class="hljs-comment">// ← Your Vite dev server URL</span>
    setupNodeEvents(on, config) {
      <span class="hljs-comment">// implement node event listeners here</span>
    },
  },
})
</div></code></pre>
<p><strong>What it does:</strong></p>
<ul>
<li><strong>🌐 Base URL</strong>: Tells Cypress where your app runs (<code>localhost:5173</code> is Vite's default)</li>
<li><strong>🔧 E2E Config</strong>: Configures end-to-end testing settings</li>
<li><strong>🪝 Node Events</strong>: Hook for advanced Cypress plugins (currently empty)</li>
</ul>
<h4 id="2-cypresse2echatbotcyts---your-test-scenarios">2. <strong><code>cypress/e2e/chatbot.cy.ts</code></strong> - Your Test Scenarios</h4>
<p>This is the <strong>main test file</strong> that contains 6 comprehensive tests:</p>
<p><strong>🧪 Test Breakdown:</strong></p>
<h5 id="test-1-application-loading"><strong>Test 1: Application Loading</strong></h5>
<pre class="hljs"><code><div>it(<span class="hljs-string">'should load the chatbot application'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cy.get(<span class="hljs-string">'[role="main"]'</span>).should(<span class="hljs-string">'be.visible'</span>);           <span class="hljs-comment">// ← Chat container exists</span>
  cy.contains(<span class="hljs-regexp">/welcome.*TDD/i</span>).should(<span class="hljs-string">'be.visible'</span>);      <span class="hljs-comment">// ← Welcome message appears</span>
});
</div></code></pre>
<h5 id="test-2-user-interaction-flow"><strong>Test 2: User Interaction Flow</strong></h5>
<pre class="hljs"><code><div>it(<span class="hljs-string">'should handle user interaction flow'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>).type(<span class="hljs-string">'hello'</span>);  <span class="hljs-comment">// ← Type message</span>
  cy.get(<span class="hljs-string">'button'</span>).contains(<span class="hljs-string">'Send'</span>).click();                       <span class="hljs-comment">// ← Click send</span>
  cy.contains(<span class="hljs-string">'hello'</span>).should(<span class="hljs-string">'be.visible'</span>);                       <span class="hljs-comment">// ← User message appears</span>
  cy.contains(<span class="hljs-regexp">/Hello.*TDD.*chatbot/i</span>, { timeout: <span class="hljs-number">2000</span> })          <span class="hljs-comment">// ← Bot responds</span>
    .should(<span class="hljs-string">'be.visible'</span>);
});
</div></code></pre>
<h5 id="test-3-keyboard-interaction"><strong>Test 3: Keyboard Interaction</strong></h5>
<pre class="hljs"><code><div>it(<span class="hljs-string">'should handle Enter key submission'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>)
    .type(<span class="hljs-string">'vite{enter}'</span>);  <span class="hljs-comment">// ← {enter} simulates Enter key press</span>
});
</div></code></pre>
<h5 id="test-4-button-state-management"><strong>Test 4: Button State Management</strong></h5>
<pre class="hljs"><code><div>it(<span class="hljs-string">'should disable send button for empty input'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cy.get(<span class="hljs-string">'button'</span>).contains(<span class="hljs-string">'Send'</span>).should(<span class="hljs-string">'be.disabled'</span>);      <span class="hljs-comment">// ← Initially disabled</span>
  <span class="hljs-comment">// ...tests enabling/disabling based on input</span>
});
</div></code></pre>
<h5 id="test-5-conversation-history"><strong>Test 5: Conversation History</strong></h5>
<pre class="hljs"><code><div>it(<span class="hljs-string">'should maintain conversation history'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Sends multiple messages and verifies all remain visible</span>
});
</div></code></pre>
<h5 id="test-6-accessibility-testing"><strong>Test 6: Accessibility Testing</strong></h5>
<pre class="hljs"><code><div>it(<span class="hljs-string">'should have proper accessibility attributes'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cy.get(<span class="hljs-string">'[role="main"]'</span>).should(<span class="hljs-string">'exist'</span>);    <span class="hljs-comment">// ← ARIA roles</span>
  cy.get(<span class="hljs-string">'[role="log"]'</span>).should(<span class="hljs-string">'exist'</span>);     <span class="hljs-comment">// ← Semantic HTML</span>
  cy.get(<span class="hljs-string">'[role="listitem"]'</span>).should(<span class="hljs-string">'exist'</span>); <span class="hljs-comment">// ← List structure</span>
});
</div></code></pre>
<h4 id="3-cypresssupporte2ets---global-setup">3. <strong><code>cypress/support/e2e.ts</code></strong> - Global Setup</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// Import commands.ts using ES2015 syntax:</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./commands'</span>
</div></code></pre>
<p><strong>What it does:</strong></p>
<ul>
<li><strong>🔄 Auto-loaded</strong>: Runs before every test file</li>
<li><strong>🌍 Global Setup</strong>: Perfect for app-wide configurations</li>
<li><strong>📦 Import Commands</strong>: Loads your custom Cypress commands</li>
</ul>
<h4 id="4-cypresssupportcommandsts---custom-commands">4. <strong><code>cypress/support/commands.ts</code></strong> - Custom Commands</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">declare</span> global {
  <span class="hljs-keyword">namespace</span> Cypress {
    <span class="hljs-keyword">interface</span> Chainable {
      <span class="hljs-comment">// Add custom command type definitions here</span>
    }
  }
}
</div></code></pre>
<p><strong>What it's for:</strong></p>
<ul>
<li><strong>🛠️ Custom Commands</strong>: Define reusable test actions</li>
<li><strong>📝 TypeScript Support</strong>: Type definitions for custom commands</li>
<li><strong>♻️ DRY Principle</strong>: Avoid repeating complex test sequences</li>
</ul>
<p><strong>Example custom command you could add:</strong></p>
<pre class="hljs"><code><div>Cypress.Commands.add(<span class="hljs-string">'sendChatMessage'</span>, <span class="hljs-function">(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
  cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>).type(message);
  cy.get(<span class="hljs-string">'button'</span>).contains(<span class="hljs-string">'Send'</span>).click();
});

<span class="hljs-comment">// Then use in tests:</span>
cy.sendChatMessage(<span class="hljs-string">'hello'</span>);
</div></code></pre>
<h4 id="5-cypressdownloads---downloaded-files">5. <strong><code>cypress/downloads/</code></strong> - Downloaded Files</h4>
<ul>
<li><strong>📁 Purpose</strong>: Stores files downloaded during tests</li>
<li><strong>🧪 Testing Downloads</strong>: Verify file downloads work correctly</li>
<li><strong>🗂️ Auto-created</strong>: Cypress creates this automatically</li>
</ul>
<h2 id="%F0%9F%8E%AF-how-these-files-work-together">🎯 How These Files Work Together</h2>
<pre class="hljs"><code><div>cypress.config.ts
    ↓
Sets baseUrl &amp; config
    ↓
cypress/support/e2e.ts
    ↓
Loads global setup
    ↓
cypress/support/commands.ts
    ↓
Provides custom commands
    ↓
cypress/e2e/chatbot.cy.ts
    ↓
Runs actual tests using config &amp; commands
</div></code></pre>
<h2 id="%F0%9F%92%A1-why-e2e-testing-matters">💡 Why E2E Testing Matters</h2>
<p><strong>🧪 Unit Tests</strong>: Test individual functions<br>
<strong>🔗 Integration Tests</strong>: Test component interactions<br>
<strong>🌐 E2E Tests</strong>: Test the <strong>complete user experience</strong></p>
<p>Your Cypress tests verify:</p>
<ul>
<li>✅ App loads correctly</li>
<li>✅ Users can interact with the chatbot</li>
<li>✅ Messages appear and persist</li>
<li>✅ Accessibility standards are met</li>
<li>✅ Real browser behavior (not just simulated)</li>
</ul>
<p>This completes your <strong>Testing Pyramid</strong> - you now have comprehensive test coverage from the smallest units to the full user experience!</p>
<h3 id="%F0%9F%9A%80-running-cypress-e2e-tests">🚀 Running Cypress E2E Tests</h3>
<p><strong>Step 1: Start Your Development Server</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># In one terminal, start the development server</span>
npm run dev
</div></code></pre>
<p>This will start your app at <code>http://localhost:5173/</code></p>
<p><strong>Step 2: Open Cypress Browser Interface</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># In another terminal, open Cypress</span>
npm run <span class="hljs-built_in">test</span>:e2e
</div></code></pre>
<p>You need to allow the network (if prompt)</p>
<p>You'll see the Cypress welcome screen:</p>
<p><img src="cypress-welcome.png" alt="Cypress Welcome Screen"></p>
<p><strong>Step 3: Use Cypress Browser</strong></p>
<ol>
<li><strong>Select &quot;E2E Testing&quot;</strong> in the Cypress launchpad</li>
<li><strong>Choose your browser</strong> (Chrome recommended)</li>
</ol>
<p><img src="cypress-browser-selection.png" alt="Cypress Browser Selection"></p>
<ol start="3">
<li><strong>Click &quot;Start E2E Testing&quot;</strong></li>
<li><strong>Navigate to your test specs</strong></li>
</ol>
<p><img src="cypress-specs-dashboard.png" alt="Cypress Specs Dashboard"></p>
<ol start="5">
<li><strong>Click on <code>chatbot.cy.ts</code></strong> to run your tests</li>
<li><strong>Watch the tests execute</strong> in real-time!</li>
</ol>
<p><img src="cypress-test-execution.png" alt="Cypress Test Execution"></p>
<p><strong>What you'll see in the test execution:</strong></p>
<ul>
<li>✅ <strong>All 6 tests passing</strong> with green checkmarks</li>
<li>🌐 <strong>Live chatbot app</strong> running in the right panel</li>
<li>📝 <strong>Test commands</strong> listed on the left (should load, handle user interaction, etc.)</li>
<li>💬 <strong>Real conversation</strong> happening in your app as tests run</li>
<li>🔍 <strong>Interactive debugging</strong> - click any test step to see the app state at that moment</li>
</ul>
<h3 id="%F0%9F%9A%A8-common-cypress-issues-and-solutions">🚨 Common Cypress Issues and Solutions</h3>
<p><strong>Issue 1: &quot;Cypress configuration error - supportFile missing&quot;</strong></p>
<p><strong>Problem</strong>: Cypress expects support files that don't exist by default.</p>
<p><strong>Solution</strong>: Create the support files (shown above) or disable them:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// In cypress.config.ts, add:</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig({
  e2e: {
    baseUrl: <span class="hljs-string">'http://localhost:5173'</span>,
    supportFile: <span class="hljs-literal">false</span>, <span class="hljs-comment">// Disable if you don't want support files</span>
    setupNodeEvents(on, config) {
      <span class="hljs-comment">// implement node event listeners here</span>
    },
  },
})
</div></code></pre>
<p><strong>Issue 2: &quot;Cannot connect to localhost:5173&quot;</strong></p>
<p><strong>Problem</strong>: Your development server isn't running.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>Make sure <code>npm run dev</code> is running in another terminal</li>
<li>Verify the app loads at <code>http://localhost:5173/</code> in your browser</li>
<li>Check the <code>baseUrl</code> in <code>cypress.config.ts</code> matches your dev server URL</li>
</ol>
<p><strong>Issue 3: Tests fail with &quot;element not found&quot;</strong></p>
<p><strong>Problem</strong>: Elements don't match the selectors in tests.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>Run your app manually and inspect elements</li>
<li>Update selectors in your test file to match actual HTML</li>
<li>Use Cypress's interactive mode to debug selector issues</li>
</ol>
<h3 id="%F0%9F%8E%AF-what-youll-see-in-cypress">🎯 What You'll See in Cypress</h3>
<p><strong>Live Browser Testing:</strong></p>
<ul>
<li>🌐 <strong>Real browser</strong> showing your chatbot app</li>
<li>📝 <strong>Test commands</strong> executing step-by-step</li>
<li>✅ <strong>Green checkmarks</strong> for passing tests</li>
<li>❌ <strong>Red X marks</strong> for failing tests with detailed error info</li>
</ul>
<p><strong>Interactive Features:</strong></p>
<ul>
<li>🔍 <strong>Time travel debugging</strong> - click any command to see app state</li>
<li>⏸️ <strong>Pause tests</strong> - add <code>cy.pause()</code> to stop and inspect</li>
<li>📱 <strong>Responsive testing</strong> - test different screen sizes</li>
<li>📊 <strong>Network monitoring</strong> - see all HTTP requests</li>
</ul>
<p><strong>Your Test Results:</strong></p>
<ul>
<li>✅ <strong>App loads</strong> and welcome message appears</li>
<li>✅ <strong>User messages</strong> are sent and displayed</li>
<li>✅ <strong>Bot responses</strong> appear after user messages</li>
<li>✅ <strong>Enter key</strong> works for message submission</li>
<li>✅ <strong>Button states</strong> work correctly (enabled/disabled)</li>
<li>✅ <strong>Conversation history</strong> is maintained</li>
<li>✅ <strong>Accessibility</strong> attributes are present</li>
</ul>
<h3 id="%F0%9F%92%A1-cypress-pro-tips">💡 Cypress Pro Tips</h3>
<p><strong>1. Use cy.pause() for debugging:</strong></p>
<pre class="hljs"><code><div>it(<span class="hljs-string">'should debug a specific issue'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  cy.visit(<span class="hljs-string">'/'</span>);
  cy.pause(); <span class="hljs-comment">// Test will pause here, you can inspect manually</span>
  cy.get(<span class="hljs-string">'button'</span>).click();
});
</div></code></pre>
<p><strong>2. Test with realistic delays:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Wait for animations or API calls</span>
cy.contains(<span class="hljs-string">'Bot response'</span>, { timeout: <span class="hljs-number">5000</span> }).should(<span class="hljs-string">'be.visible'</span>);
</div></code></pre>
<p><strong>3. Use custom commands for common actions:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// In commands.ts</span>
Cypress.Commands.add(<span class="hljs-string">'sendMessage'</span>, <span class="hljs-function">(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
  cy.get(<span class="hljs-string">'input[placeholder*="Type your message"]'</span>).type(message);
  cy.get(<span class="hljs-string">'button'</span>).contains(<span class="hljs-string">'Send'</span>).click();
});

<span class="hljs-comment">// In your test</span>
cy.sendMessage(<span class="hljs-string">'hello'</span>);
</div></code></pre>
<p><strong>4. Test multiple scenarios:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> testMessages = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'vite'</span>, <span class="hljs-string">'react'</span>, <span class="hljs-string">'goodbye'</span>];
testMessages.forEach(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> {
  cy.sendMessage(message);
  cy.contains(message).should(<span class="hljs-string">'be.visible'</span>);
});
</div></code></pre>
<h2 id="%F0%9F%9A%80-step-16-simple-api-mocking-with-jest">🚀 Step 16: Simple API Mocking with Jest</h2>
<h3 id="mocking-external-dependencies">Mocking External Dependencies</h3>
<p>When testing components that make API calls, we need to mock those calls to avoid:</p>
<ul>
<li>❌ Making real HTTP requests during tests (slow and unreliable)</li>
<li>❌ Depending on external services being available</li>
<li>❌ Getting different responses each time (flaky tests)</li>
<li>❌ Hitting rate limits or costing money on API calls</li>
</ul>
<p><strong>Instead, use simple Jest mocks to:</strong></p>
<ul>
<li>✅ Get instant, predictable responses</li>
<li>✅ Test error scenarios easily</li>
<li>✅ Control exactly what data your components receive</li>
<li>✅ Keep tests fast and focused on your code</li>
</ul>
<h3 id="simple-mock-approach">Simple Mock Approach</h3>
<p>Jest provides excellent built-in mocking capabilities that are perfect for learning TDD:</p>
<p><strong>Update <code>src/setupTests.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// ⚙️ Essential Testing Environment Setup</span>
<span class="hljs-comment">// Import Jest DOM matchers for enhanced testing assertions</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'@testing-library/jest-dom'</span>;

<span class="hljs-comment">// Global mock for scrollIntoView - jsdom doesn't implement this browser API</span>
<span class="hljs-built_in">Object</span>.defineProperty(Element.prototype, <span class="hljs-string">'scrollIntoView'</span>, {
  value: jest.fn(),
  writable: <span class="hljs-literal">true</span>,
});

<span class="hljs-comment">// Global fetch mock - we'll override this in individual tests</span>
global.fetch = jest.fn();
</div></code></pre>
<h3 id="example-testing-components-with-api-calls">Example: Testing Components with API Calls</h3>
<p><strong>Example: Testing a Chat Service</strong></p>
<p>Let's create a simple example showing how to test API calls:</p>
<p><strong>Create <code>src/services/__tests__/chatService.test.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { getChatResponse } <span class="hljs-keyword">from</span> <span class="hljs-string">'../chatService'</span>;

<span class="hljs-comment">// Mock fetch globally for this test file</span>
<span class="hljs-keyword">const</span> mockFetch = global.fetch <span class="hljs-keyword">as</span> jest.Mock;

describe(<span class="hljs-string">'Chat Service'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// Clear all mocks before each test</span>
    mockFetch.mockClear();
  });

  it(<span class="hljs-string">'should return chat response on successful API call'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// Arrange: Setup mock response</span>
    mockFetch.mockResolvedValue({
      ok: <span class="hljs-literal">true</span>,
      json: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve({ 
        message: <span class="hljs-string">'Hello! How can I help you?'</span> 
      })
    });

    <span class="hljs-comment">// Act: Call the function</span>
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> getChatResponse(<span class="hljs-string">'Hello'</span>);

    <span class="hljs-comment">// Assert: Check the result</span>
    expect(response).toEqual({ 
      message: <span class="hljs-string">'Hello! How can I help you?'</span> 
    });
    expect(mockFetch).toHaveBeenCalledWith(<span class="hljs-string">'/api/chat'</span>, {
      method: <span class="hljs-string">'POST'</span>,
      headers: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
      body: <span class="hljs-built_in">JSON</span>.stringify({ message: <span class="hljs-string">'Hello'</span> })
    });
  });

  it(<span class="hljs-string">'should handle API errors gracefully'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// Arrange: Setup mock error</span>
    mockFetch.mockRejectedValue(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Network error'</span>));

    <span class="hljs-comment">// Act &amp; Assert: Expect the function to throw</span>
    <span class="hljs-keyword">await</span> expect(getChatResponse(<span class="hljs-string">'Hello'</span>)).rejects.toThrow(<span class="hljs-string">'Network error'</span>);
  });

  it(<span class="hljs-string">'should handle HTTP error status'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// Arrange: Setup mock HTTP error</span>
    mockFetch.mockResolvedValue({
      ok: <span class="hljs-literal">false</span>,
      status: <span class="hljs-number">500</span>,
      statusText: <span class="hljs-string">'Internal Server Error'</span>
    });

    <span class="hljs-comment">// Act &amp; Assert</span>
    <span class="hljs-keyword">await</span> expect(getChatResponse(<span class="hljs-string">'Hello'</span>)).rejects.toThrow(<span class="hljs-string">'HTTP error: 500'</span>);
  });
});
</div></code></pre>
<p><strong>Create the service function <code>src/services/chatService.ts</code>:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ChatResponse {
  message: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChatResponse</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ChatResponse</span>&gt; </span>{
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'/api/chat'</span>, {
    method: <span class="hljs-string">'POST'</span>,
    headers: {
      <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
    },
    body: <span class="hljs-built_in">JSON</span>.stringify({ message }),
  });

  <span class="hljs-keyword">if</span> (!response.ok) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`HTTP error: <span class="hljs-subst">${response.status}</span>`</span>);
  }

  <span class="hljs-keyword">return</span> response.json();
}
</div></code></pre>
<h3 id="testing-react-components-with-api-calls">Testing React Components with API Calls</h3>
<p><strong>Example: Testing a component that uses the chat service</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { render, screen, waitFor } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> userEvent <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/user-event'</span>;
<span class="hljs-keyword">import</span> { ChatWithAPI } <span class="hljs-keyword">from</span> <span class="hljs-string">'../ChatWithAPI'</span>;

<span class="hljs-comment">// Mock the chat service module</span>
jest.mock(<span class="hljs-string">'../services/chatService'</span>);
<span class="hljs-keyword">import</span> { getChatResponse } <span class="hljs-keyword">from</span> <span class="hljs-string">'../services/chatService'</span>;

<span class="hljs-keyword">const</span> mockGetChatResponse = getChatResponse <span class="hljs-keyword">as</span> jest.Mock;

describe(<span class="hljs-string">'ChatWithAPI Component'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    mockGetChatResponse.mockClear();
  });

  it(<span class="hljs-string">'should display bot response when user sends message'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// Arrange: Setup mock response</span>
    mockGetChatResponse.mockResolvedValue({
      message: <span class="hljs-string">'Hello! How can I help you?'</span>
    });

    <span class="hljs-keyword">const</span> user = userEvent.setup();
    render(&lt;ChatWithAPI /&gt;);

    <span class="hljs-comment">// Act: Send a message</span>
    <span class="hljs-keyword">const</span> input = screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>);
    <span class="hljs-keyword">await</span> user.type(input, <span class="hljs-string">'Hello bot'</span>);
    <span class="hljs-keyword">await</span> user.click(screen.getByText(<span class="hljs-string">'Send'</span>));

    <span class="hljs-comment">// Assert: Check that the service was called</span>
    expect(mockGetChatResponse).toHaveBeenCalledWith(<span class="hljs-string">'Hello bot'</span>);

    <span class="hljs-comment">// Assert: Check that the response appears in the UI</span>
    <span class="hljs-keyword">await</span> waitFor(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      expect(screen.getByText(<span class="hljs-string">'Hello! How can I help you?'</span>)).toBeInTheDocument();
    });
  });

  it(<span class="hljs-string">'should handle API errors gracefully'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// Arrange: Setup mock error</span>
    mockGetChatResponse.mockRejectedValue(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Network error'</span>));

    <span class="hljs-keyword">const</span> user = userEvent.setup();
    render(&lt;ChatWithAPI /&gt;);

    <span class="hljs-comment">// Act: Send a message</span>
    <span class="hljs-keyword">await</span> user.type(screen.getByPlaceholderText(<span class="hljs-regexp">/type your message/i</span>), <span class="hljs-string">'Hello'</span>);
    <span class="hljs-keyword">await</span> user.click(screen.getByText(<span class="hljs-string">'Send'</span>));

    <span class="hljs-comment">// Assert: Should show error message in UI</span>
    <span class="hljs-keyword">await</span> waitFor(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      expect(screen.getByText(<span class="hljs-regexp">/something went wrong/i</span>)).toBeInTheDocument();
    });
  });
});
</div></code></pre>
<h3 id="testing-custom-hooks-with-api-calls">Testing Custom Hooks with API Calls</h3>
<p><strong>Example: Testing a custom hook that manages chat state</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { renderHook, act, waitFor } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> { useChatWithAPI } <span class="hljs-keyword">from</span> <span class="hljs-string">'../useChatWithAPI'</span>;

<span class="hljs-comment">// Mock the chat service</span>
jest.mock(<span class="hljs-string">'../services/chatService'</span>);
<span class="hljs-keyword">import</span> { getChatResponse } <span class="hljs-keyword">from</span> <span class="hljs-string">'../services/chatService'</span>;

<span class="hljs-keyword">const</span> mockGetChatResponse = getChatResponse <span class="hljs-keyword">as</span> jest.Mock;

describe(<span class="hljs-string">'useChatWithAPI'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    mockGetChatResponse.mockClear();
  });

  it(<span class="hljs-string">'should add user message and bot response'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// Arrange</span>
    mockGetChatResponse.mockResolvedValue({
      message: <span class="hljs-string">'Bot response'</span>
    });

    <span class="hljs-keyword">const</span> { result } = renderHook(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> useChatWithAPI());

    <span class="hljs-comment">// Act</span>
    <span class="hljs-keyword">await</span> act(<span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">await</span> result.current.sendMessage(<span class="hljs-string">'User message'</span>);
    });

    <span class="hljs-comment">// Assert</span>
    <span class="hljs-keyword">await</span> waitFor(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      expect(result.current.messages).toHaveLength(<span class="hljs-number">2</span>);
      expect(result.current.messages[<span class="hljs-number">0</span>].text).toBe(<span class="hljs-string">'User message'</span>);
      expect(result.current.messages[<span class="hljs-number">0</span>].sender).toBe(<span class="hljs-string">'user'</span>);
      expect(result.current.messages[<span class="hljs-number">1</span>].text).toBe(<span class="hljs-string">'Bot response'</span>);
      expect(result.current.messages[<span class="hljs-number">1</span>].sender).toBe(<span class="hljs-string">'bot'</span>);
    });
  });

  it(<span class="hljs-string">'should handle API errors'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-comment">// Arrange</span>
    mockGetChatResponse.mockRejectedValue(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Network error'</span>));

    <span class="hljs-keyword">const</span> { result } = renderHook(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> useChatWithAPI());

    <span class="hljs-comment">// Act</span>
    <span class="hljs-keyword">await</span> act(<span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">await</span> result.current.sendMessage(<span class="hljs-string">'Test message'</span>);
    });

    <span class="hljs-comment">// Assert</span>
    <span class="hljs-keyword">await</span> waitFor(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      expect(result.current.error).toBe(<span class="hljs-string">'Network error'</span>);
    });
  });
});
</div></code></pre>
<h3 id="benefits-of-simple-jest-mocking">Benefits of Simple Jest Mocking</h3>
<p><strong>🎯 Perfect for Learning TDD:</strong></p>
<ul>
<li>✅ No additional dependencies to manage</li>
<li>✅ Simple, clear syntax that's easy to understand</li>
<li>✅ Built into Jest - no extra setup required</li>
<li>✅ Excellent documentation and community support</li>
</ul>
<p><strong>🔧 Powerful Testing Capabilities:</strong></p>
<ul>
<li>✅ Mock return values: <code>mockResolvedValue()</code>, <code>mockRejectedValue()</code></li>
<li>✅ Verify function calls: <code>toHaveBeenCalledWith()</code></li>
<li>✅ Control implementation: <code>mockImplementation()</code></li>
<li>✅ Clear mocks: <code>mockClear()</code>, <code>mockReset()</code></li>
</ul>
<p><strong>📚 Learning Focus:</strong></p>
<ul>
<li>✅ Concentrates on TDD principles, not mocking library syntax</li>
<li>✅ Teaches fundamental testing concepts</li>
<li>✅ Easy to transition to other mocking approaches later</li>
<li>✅ Builds strong testing foundations</li>
</ul>
<h2 id="tdd-best-practices-and-common-pitfalls">TDD Best Practices and Common Pitfalls</h2>
<h3 id="best-practices-weve-demonstrated">Best Practices We've Demonstrated</h3>
<ol>
<li><strong>Start Small</strong>: Begin with simple utility functions</li>
<li><strong>Red-Green-Refactor</strong>: Always follow the cycle</li>
<li><strong>Test Behavior, Not Implementation</strong>: Focus on what the code does</li>
<li><strong>Meaningful Test Names</strong>: Describe the expected behavior</li>
<li><strong>Arrange-Act-Assert</strong>: Structure tests clearly</li>
<li><strong>Mock External Dependencies</strong>: Keep tests fast and isolated</li>
</ol>
<h3 id="common-pitfalls-to-avoid">Common Pitfalls to Avoid</h3>
<ol>
<li><strong>Writing Tests After Code</strong> (retrofitting)</li>
<li><strong>Over-mocking</strong>: Mocking too many dependencies</li>
<li><strong>Ignoring the Refactor Phase</strong>: Not cleaning up code</li>
<li><strong>Testing Implementation Details</strong>: Testing how instead of what</li>
<li><strong>Writing Too Many Tests at Once</strong>: Stick to one failing test</li>
</ol>
<h3 id="refactoring-principles-applied---detailed-newbie-explanation">Refactoring Principles Applied - Detailed Newbie Explanation</h3>
<p>Here's a real example from our Chat component that shows how refactoring improves code:</p>
<p><strong>🤔 The Problem: Duplicated Message Creation Logic</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Before refactoring (duplication and complexity)</span>
<span class="hljs-keyword">const</span> handleSend = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (input.trim() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span>;
  
  <span class="hljs-comment">// Creating message manually - lots of details to remember!</span>
  <span class="hljs-keyword">const</span> newMessage = {
    id: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)}</span>`</span>,  <span class="hljs-comment">// Complex ID generation</span>
    text: input.trim(),                                               <span class="hljs-comment">// Clean up text</span>
    sender: <span class="hljs-string">'user'</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>,                                          <span class="hljs-comment">// Set sender type</span>
    timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()                                             <span class="hljs-comment">// Add timestamp</span>
  };
  
  <span class="hljs-comment">// Update state manually</span>
  setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, newMessage]);
  setInput(<span class="hljs-string">''</span>);
};
</div></code></pre>
<p><strong>Problems with this approach:</strong></p>
<ol>
<li><strong>Code Duplication</strong>: If we need to create messages elsewhere, we copy all this logic</li>
<li><strong>Error Prone</strong>: Easy to forget a property or make a typo</li>
<li><strong>Hard to Maintain</strong>: Changes to message structure require updating multiple places</li>
<li><strong>Violates DRY</strong>: &quot;Don't Repeat Yourself&quot; - we're repeating message creation logic</li>
<li><strong>Complex</strong>: Too many details in one function</li>
</ol>
<p><strong>✨ After Refactoring (Clean and Simple):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// After refactoring (extracted logic)</span>
<span class="hljs-keyword">const</span> handleSend = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (input.trim() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span>;
  addMessage(input.trim(), <span class="hljs-string">'user'</span>);  <span class="hljs-comment">// Simple, clear, reusable!</span>
  setInput(<span class="hljs-string">''</span>);
};
</div></code></pre>
<p><strong>🔍 What Happened During Refactoring:</strong></p>
<p><strong>Step 1: Extract Message Creation</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🔄 Refactor Step A: Extracted Message Creation (REFACTOR Phase)</span>
<span class="hljs-comment">// We moved the complex logic to a reusable hook:</span>
<span class="hljs-keyword">const</span> addMessage = <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, sender: 'user' | 'bot'</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> newMessage: Message = {
    id: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)}</span>`</span>,
    text,
    sender,
    timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
  };
  setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, newMessage]);
};
</div></code></pre>
<p><strong>Step 2: Simplify the Handler</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🔄 Refactor Step B: Simplified Handler (REFACTOR Phase)</span>
<span class="hljs-comment">// Now handleSend only cares about input validation and UI updates</span>
<span class="hljs-keyword">const</span> handleSend = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (input.trim() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Validation</span>
  addMessage(input.trim(), <span class="hljs-string">'user'</span>); <span class="hljs-comment">// Delegate message creation</span>
  setInput(<span class="hljs-string">''</span>);                     <span class="hljs-comment">// UI cleanup</span>
};
</div></code></pre>
<p><strong>📋 Complete Final Code for Chat Component (After Refactor):</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// � Step 16: Complete Refactored Chat Component (REFACTOR Phase)</span>
<span class="hljs-comment">// �💬 Chat Component Implementation (After Refactoring)</span>
<span class="hljs-comment">// Shows how extracting the useMessages hook simplifies the component</span>

<span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { MessageComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./MessageComponent'</span>;
<span class="hljs-keyword">import</span> { ChatInput } <span class="hljs-keyword">from</span> <span class="hljs-string">'./ChatInput'</span>;
<span class="hljs-keyword">import</span> { useMessages } <span class="hljs-keyword">from</span> <span class="hljs-string">'../hooks/useMessages'</span>;  <span class="hljs-comment">// Our custom hook</span>
<span class="hljs-keyword">import</span> { getBotResponse } <span class="hljs-keyword">from</span> <span class="hljs-string">'../services/botService'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Chat</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Local state for input handling</span>
  <span class="hljs-keyword">const</span> [input, setInput] = useState(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> [isLoading, setIsLoading] = useState(<span class="hljs-literal">false</span>);
  
  <span class="hljs-comment">// Use our custom hook - handles all message state management</span>
  <span class="hljs-keyword">const</span> { messages, addMessage } = useMessages();

  <span class="hljs-comment">// Simplified message sending (no longer handles message creation details)</span>
  <span class="hljs-keyword">const</span> handleSend = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">if</span> (input.trim() === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Validation only</span>
    
    <span class="hljs-comment">// Create user message using the hook</span>
    addMessage(input.trim(), <span class="hljs-string">'user'</span>);
    setInput(<span class="hljs-string">''</span>);                     <span class="hljs-comment">// Clear input</span>
    setIsLoading(<span class="hljs-literal">true</span>);              <span class="hljs-comment">// Show loading state</span>
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Get bot response</span>
      <span class="hljs-keyword">const</span> botResponse = getBotResponse(input.trim());
      
      <span class="hljs-comment">// Add bot message after delay (simulate thinking time)</span>
      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        addMessage(botResponse.text, <span class="hljs-string">'bot'</span>);
        setIsLoading(<span class="hljs-literal">false</span>);
      }, botResponse.delay);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// Handle errors gracefully</span>
      addMessage(<span class="hljs-string">'Sorry, something went wrong. Please try again.'</span>, <span class="hljs-string">'bot'</span>);
      setIsLoading(<span class="hljs-literal">false</span>);
    }
  };

  <span class="hljs-comment">// Handle Enter key press for better UX</span>
  <span class="hljs-keyword">const</span> handleKeyPress = <span class="hljs-function">(<span class="hljs-params">e: React.KeyboardEvent</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (e.key === <span class="hljs-string">'Enter'</span> &amp;&amp; !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  <span class="hljs-keyword">return</span> (
    &lt;div className=<span class="hljs-string">"chat-container"</span>&gt;
      {<span class="hljs-comment">/* Header */</span>}
      &lt;div className=<span class="hljs-string">"chat-header"</span>&gt;
        &lt;h2&gt;🤖 TDD Chatbot&lt;<span class="hljs-regexp">/h2&gt;
        &lt;p&gt;Built with Test-Driven Development&lt;/</span>p&gt;
      &lt;<span class="hljs-regexp">/div&gt;
      
      {/</span>* Messages Display *<span class="hljs-regexp">/}
      &lt;div className="messages-container"&gt;
        {messages.length === 0 ? (
          &lt;div className="welcome-message"&gt;
            &lt;p&gt;👋 Welcome! I'm a chatbot built using TDD.&lt;/</span>p&gt;
            &lt;p&gt;Try saying <span class="hljs-string">"hello"</span>, <span class="hljs-string">"vite"</span>, <span class="hljs-string">"react"</span>, or <span class="hljs-string">"bye"</span>!&lt;<span class="hljs-regexp">/p&gt;
          &lt;/</span>div&gt;
        ) : (
          messages.map(<span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> (
            &lt;MessageComponent 
              key={message.id} 
              message={message} 
            /&gt;
          ))
        )}
        
        {<span class="hljs-comment">/* Loading indicator */</span>}
        {isLoading &amp;&amp; (
          &lt;div className=<span class="hljs-string">"loading-message"</span>&gt;
            &lt;span&gt;🤖 Bot is thinking...&lt;<span class="hljs-regexp">/span&gt;
          &lt;/</span>div&gt;
        )}
      &lt;<span class="hljs-regexp">/div&gt;
      
      {/</span>* Input Area *<span class="hljs-regexp">/}
      &lt;ChatInput
        value={input}
        onChange={setInput}
        onSend={handleSend}
        onKeyPress={handleKeyPress}
        disabled={isLoading}
        placeholder="Type your message..."
      /</span>&gt;
    &lt;<span class="hljs-regexp">/div&gt;
  );
}
</span></div></code></pre>
<p><strong>📋 Complete Final Code for useMessages Hook:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 🪝 Custom Hook Implementation (After Refactoring)</span>
<span class="hljs-comment">// Extracted message management logic for reusability</span>

<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { Message } <span class="hljs-keyword">from</span> <span class="hljs-string">'../types/Message'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useMessages</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// State to hold all messages</span>
  <span class="hljs-keyword">const</span> [messages, setMessages] = useState&lt;Message[]&gt;([]);

  <span class="hljs-comment">// Extracted function - handles ALL message creation complexity</span>
  <span class="hljs-keyword">const</span> addMessage = <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, sender: 'user' | 'bot'</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> newMessage: Message = {
      <span class="hljs-comment">// Generate unique ID using timestamp + random string</span>
      id: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>-<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)}</span>`</span>,
      text: text.trim(),           <span class="hljs-comment">// Clean up text</span>
      sender,                      <span class="hljs-comment">// 'user' or 'bot'</span>
      timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()        <span class="hljs-comment">// Current time</span>
    };
    
    <span class="hljs-comment">// Update state immutably</span>
    setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, newMessage]);
  };

  <span class="hljs-comment">// Clear all messages (useful for reset functionality)</span>
  <span class="hljs-keyword">const</span> clearMessages = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setMessages([]);
  };

  <span class="hljs-comment">// Get the last message (useful for getting last bot response)</span>
  <span class="hljs-keyword">const</span> getLastMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> messages.length &gt; <span class="hljs-number">0</span> ? messages[messages.length - <span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>;
  };

  <span class="hljs-comment">// Get messages by sender type</span>
  <span class="hljs-keyword">const</span> getMessagesBySender = <span class="hljs-function">(<span class="hljs-params">sender: 'user' | 'bot'</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> messages.filter(<span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> message.sender === sender);
  };

  <span class="hljs-keyword">return</span> {
    messages,              <span class="hljs-comment">// Current messages array</span>
    addMessage,           <span class="hljs-comment">// Add new message function</span>
    clearMessages,        <span class="hljs-comment">// Clear all messages</span>
    getLastMessage,       <span class="hljs-comment">// Get last message</span>
    getMessagesBySender   <span class="hljs-comment">// Filter by sender</span>
  };
}
</div></code></pre>
<p><strong>🎯 Benefits of This Refactor:</strong></p>
<p><strong>1. Reusability:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Can create messages anywhere easily:</span>
addMessage(<span class="hljs-string">'Welcome!'</span>, <span class="hljs-string">'bot'</span>);           <span class="hljs-comment">// Bot message</span>
addMessage(userInput, <span class="hljs-string">'user'</span>);           <span class="hljs-comment">// User message  </span>
addMessage(<span class="hljs-string">'Error occurred'</span>, <span class="hljs-string">'bot'</span>);     <span class="hljs-comment">// Error message</span>
</div></code></pre>
<p><strong>2. Single Responsibility:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Each function has ONE job:</span>
handleSend()     <span class="hljs-comment">// → Handle input submission</span>
addMessage()     <span class="hljs-comment">// → Create and store messages</span>
setInput()       <span class="hljs-comment">// → Update UI state</span>
</div></code></pre>
<p><strong>3. Easier Testing:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Can test message creation separately from UI logic:</span>
it(<span class="hljs-string">'should create message with correct properties'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  addMessage(<span class="hljs-string">'test'</span>, <span class="hljs-string">'user'</span>);
  expect(messages[<span class="hljs-number">0</span>].text).toBe(<span class="hljs-string">'test'</span>);
  expect(messages[<span class="hljs-number">0</span>].sender).toBe(<span class="hljs-string">'user'</span>);
});
</div></code></pre>
<p><strong>4. Easier Maintenance:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// Change message structure in ONE place:</span>
<span class="hljs-keyword">const</span> addMessage = <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, sender: 'user' | 'bot'</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> newMessage: Message = {
    id: generateUniqueId(),           <span class="hljs-comment">// ← Improved ID generation</span>
    text: sanitizeText(text),         <span class="hljs-comment">// ← Added text sanitization</span>
    sender,
    timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
    metadata: { source: <span class="hljs-string">'chat'</span> }      <span class="hljs-comment">// ← Added metadata</span>
  };
  setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, newMessage]);
};
</div></code></pre>
<p><strong>🧪 Refactor Safety Check:</strong></p>
<pre class="hljs"><code><div>npm <span class="hljs-built_in">test</span>
<span class="hljs-comment"># ✓ All tests still pass - refactor is safe!</span>
</div></code></pre>
<p><strong>💡 Key Refactoring Principles Demonstrated:</strong></p>
<ol>
<li><strong>Extract Functions</strong>: Move complex logic to reusable functions</li>
<li><strong>Single Responsibility</strong>: Each function does one thing well</li>
<li><strong>DRY (Don't Repeat Yourself)</strong>: Eliminate code duplication</li>
<li><strong>Separation of Concerns</strong>: UI logic separate from business logic</li>
<li><strong>Make Intent Clear</strong>: Function names explain what they do</li>
</ol>
<p><strong>🔄 The Refactoring Process:</strong></p>
<ol>
<li><strong>Identify Duplication</strong> → Find repeated code patterns</li>
<li><strong>Extract Common Logic</strong> → Move shared code to functions</li>
<li><strong>Test Everything</strong> → Ensure behavior stays the same</li>
<li><strong>Improve Names</strong> → Make code self-documenting</li>
<li><strong>Repeat</strong> → Always look for more improvements</li>
</ol>
<h2 id="running-all-tests">Running All Tests</h2>
<h3 id="test-scripts">Test Scripts</h3>
<p><strong>Run different types of tests:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Run all unit/integration tests</span>
npm <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Run tests in watch mode</span>
npm run <span class="hljs-built_in">test</span>:watch

<span class="hljs-comment"># Run tests with coverage</span>
npm run <span class="hljs-built_in">test</span>:coverage

<span class="hljs-comment"># Run E2E tests (make sure dev server is running)</span>
npm run dev &amp;
npm run <span class="hljs-built_in">test</span>:e2e

<span class="hljs-comment"># Run E2E tests headless</span>
npm run <span class="hljs-built_in">test</span>:e2e:headless
</div></code></pre>
<h3 id="coverage-report">Coverage Report</h3>
<pre class="hljs"><code><div>npm run <span class="hljs-built_in">test</span>:coverage
</div></code></pre>
<p>This should show high coverage percentages across your codebase:</p>
<pre class="hljs"><code><div>File                     | % Stmts | % Branch | % Funcs | % Lines
-------------------------|---------|----------|---------|--------
All files               |     95+ |      90+ |     95+ |     95+
 src/components          |     100 |      100 |     100 |     100
 src/hooks              |     100 |       95 |     100 |     100
 src/services           |     100 |      100 |     100 |     100
 src/utils              |     100 |      100 |     100 |     100
</div></code></pre>
<h2 id="key-tdd-takeaways">Key TDD Takeaways</h2>
<h3 id="what-weve-learned">What We've Learned</h3>
<ol>
<li><strong>TDD Process</strong>: Red-Green-Refactor cycle in practice</li>
<li><strong>Test Types</strong>: Unit, integration, and E2E tests</li>
<li><strong>Testing Tools</strong>: Jest, React Testing Library, Cypress</li>
<li><strong>Code Quality</strong>: Better design through test-first thinking</li>
<li><strong>Confidence</strong>: Refactoring without fear</li>
<li><strong>Documentation</strong>: Tests as specifications</li>
</ol>
<h3 id="benefits-realized">Benefits Realized</h3>
<ul>
<li>✅ <strong>Bug Prevention</strong>: Caught issues before they became problems</li>
<li>✅ <strong>Better Design</strong>: API design driven by usage in tests</li>
<li>✅ <strong>Refactor Safety</strong>: Changed code confidently with test coverage</li>
<li>✅ <strong>Living Documentation</strong>: Tests describe what code should do</li>
<li>✅ <strong>Development Speed</strong>: Faster debugging and fewer manual tests</li>
</ul>
<h3 id="time-investment-vs-returns">Time Investment vs. Returns</h3>
<p><strong>Initial Investment:</strong></p>
<ul>
<li>More time writing tests upfront</li>
<li>Learning testing tools and techniques</li>
<li>Setting up testing infrastructure</li>
</ul>
<p><strong>Long-term Returns:</strong></p>
<ul>
<li>Fewer bugs in production</li>
<li>Faster development cycles</li>
<li>Safer refactoring</li>
<li>Better code maintainability</li>
<li>Higher developer confidence</li>
</ul>
<h2 id="%F0%9F%8E%89-conclusion">🎉 Conclusion</h2>
<p>Test-Driven Development is more than just testing—it's a design methodology that leads to better software. By writing tests first, we:</p>
<ol>
<li><strong>Think about design before implementation</strong></li>
<li><strong>Build only what's needed to satisfy requirements</strong></li>
<li><strong>Create comprehensive test coverage naturally</strong></li>
<li><strong>Develop confidence in our code</strong></li>
<li><strong>Enable fearless refactoring</strong></li>
</ol>
<p>The chatbot we built is functionally identical to the one from Week 02-04, but it's built on a foundation of tests that give us confidence in its quality and make future changes much safer.</p>
<h3 id="%F0%9F%93%88-next-steps">📈 Next Steps</h3>
<ol>
<li><strong>Practice TDD</strong> on your own projects</li>
<li><strong>Experiment with different testing strategies</strong></li>
<li><strong>Learn advanced testing patterns</strong></li>
<li><strong>Share TDD knowledge with your team</strong></li>
<li><strong>Measure the impact</strong> on your development process</li>
</ol>
<p>Remember: TDD is a skill that improves with practice. Start small, be consistent, and gradually build your TDD muscles. The investment in learning TDD pays dividends throughout your entire career as a developer.</p>
<p><strong>Happy TDD coding!</strong> 🚀✅</p>

</body>
</html>
